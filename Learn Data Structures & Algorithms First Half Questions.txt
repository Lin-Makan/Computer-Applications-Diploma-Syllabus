
 ****** Learn Data Structures & Algorithms : Organizing Data Questions ******
        ==============================================================
         
         *** Data Structures & Algorithms ***
             ============================
                1. DSA - Home
                2. DSA - Overview
                3. DSA - Environment Setup
         
         *** Algorithm ***
             =========
               1. DSA - Algorithms Basics
               2. DSA - Asymptotic Analysis
               3. DSA - Greedy Algorithms
               4. DSA - Divide and Conquer
               5. DSA - Dynamic Programming
 
        *** Data Structures ***
            ===============
              1. DSA - Data Structure Basics
              2. DSA - Array Data Structure
   
        *** Linked Lists ***
            ============
              1. DSA - Linked List Basics
              2. DSA - Doubly Linked List
              3. DSA - Circular Linked List
      
        *** Stack & Queue *** 
            =============
              1. DSA - Stack
              2. DSA - Expression Parsing
              3. DSA - Queue
         
       *** Searching Techniques ***
           ====================
              1. DSA - Linear Search
              2. DSA - Binary Search
              3. DSA - Interpolation Search
              4. DSA - Hash Table
        
       *** Sorting Techniques ***
           ==================
              1. DSA - Sorting Algorithms
              2. DSA - Bubble Sort
              3. DSA - Insertion Sort
              4. DSA - Selection Sort
              5. DSA - Merge Sort
              6. DSA - Shell Sort
              7. DSA - Quick Sort  

_______________________________________________________________________________

         *** Data Structures & Algorithms ***
             ============================
                1. DSA - Home
                2. DSA - Overview
                3. DSA - Environment Setup

       <<<<<<<<< *** Data Structures & Algorithms *** >>>>>>>>>
                     ============================
__________________________________________________
                                                  |
      Data Structures & Algorithms                |                  
__________________________________________________|
            |
            |
1) What's the Heading ?
-----------------------
* Data Structures & Algorithms
                                                                                        
2) Definition of Data Structures & Algorithms ?
-----------------------------------------------
*
 
3) What is Data Structures & Algorithms About ?
-----------------------------------------------
*
*

4) What does Data Structures & Algorithms Do ?
----------------------------------------------
*
*

5) Advantages/Benefits of Data Structures & Algorithms :
--------------------------------------------------------
*
*
*

6) Disadvantages/Drawback of Data Structures & Algorithms :
-----------------------------------------------------------
*
*
*  

7) Examples of Data Structures & Algorithms :
---------------------------------------------
*
*
_______________________________________________________________________________

 1. <<<<<<<<< DSA - Home >>>>>>>>>

   ** Why to Learn Data Structure and Algorithms ?
       ``````````````````````````````````````````````
     + As applications are getting 'complex' and 'data rich',
  there are three common problems that applications face these
  days :
         a) Data Search −
         b) Processor speed −
         c) Multiple requests −
    
    ** Applications of Data Structure and Algorithms :
       ````````````````````````````````````````````````
    + From the data structure point of view,
  following are some important categories of algorithms −
          
      a) Search -
      b) Sort -
      c) Insert -
      d) Update -
      e) Delete -
  
    + The following computer problems can be solved using Data Structures :
             
           a) Fibonacci number series
           b) Knapsack problem
           c) Tower of Hanoi
           d) All pair shortest path by Floyd-Warshall
           e) Shortest path by Dijkstra
           f) Project scheduling
__________________________________________________
                                                  |
         DSA - Home                               |                  
__________________________________________________|
            |
            |
1) What's the Heading ?
-----------------------
* DSA - Home
                                                                                        
2) Definition of DSA - Home ?
-----------------------------
*
 
3) What is DSA - Home About ?
-----------------------------
*
*

4) What does DSA - Home Do ?
----------------------------
*
*

5) Advantages/Benefits of DSA - Home :
--------------------------------------
*
*
*

6) Disadvantages/Drawback of DSA - Home :
-----------------------------------------
*
*
*  

7) Examples of DSA - Home :
---------------------------
*
*
_______________________________________________________________________________

 2. <<<<<<<<< DSA - Overview >>>>>>>>>

     * the foundation terms of a data structure -
             
             a) Interface -
             b) Implementation -
       
        ** Characteristics of a Data Structure :
           ```````````````````````````````````````
                 a) Correctness -
                 b) Time Complexity -
                 c) Space Complexity -
        
        ** Need for Data Structure :
           ``````````````````````````
               a) Data Search -
               b) Processor Speed -
               c) Multiple Requests -
      
        ** Execution Time Cases :
           ````````````````````````
     * There are three cases which are usually used to compare various
       data structure's execution time -

                 a) Worst Case -
                 b) Average Case -
                 c) Best Case - 
        
       ** Basic Terminology :
          `````````````````````
             a) Data -
             b) Data Item -
             c) Group Items -
             d) Elementary Items -
             e) Attribute and Entity -
             f) Entity Set -
             g) Field -
             h) Record -
             i) File -
__________________________________________________
                                                  |
         DSA - Overview                           |                  
__________________________________________________|
            |
            |
1) What's the Heading ?
-----------------------
* DSA - Overview
                                                                                        
2) Definition of DSA - Overview ?
---------------------------------
*
 
3) What is DSA - Overview About ?
---------------------------------
*
*

4) What does DSA - Overview Do ?
--------------------------------
*
*

5) Advantages/Benefits of DSA - Overview :
------------------------------------------
*
*
*

6) Disadvantages/Drawback of DSA - Overview :
---------------------------------------------
*
*
*  

7) Examples of DSA - Overview :
-------------------------------
*
*
_______________________________________________________________________________

 3. <<<<<<<<< DSA - Environment Setup >>>>>>>>>
 
         * Local Environment Setup -
       to set up your environment for C programming language,
   you need the following two tools available on your computer :
             
            a) Text Editor
            b) The C Compiler 
         
       ** Installation on UNIX/Linux -
       ** Installation on Mac OS -
       ** Installation on Windows -
__________________________________________________
                                                  |
       DSA - Environment Setup                    |                  
__________________________________________________|
            |
            |
1) What's the Heading ?
-----------------------
* DSA - Environment Setup
                                                                                        
2) Definition of DSA - Environment Setup ?
------------------------------------------
*
 
3) What is DSA - Environment Setup About ?
------------------------------------------
*
*

4) What does DSA - Environment Setup Do ?
-----------------------------------------
*
*

5) Advantages/Benefits of DSA - Environment Setup :
---------------------------------------------------
*
*
*

6) Disadvantages/Drawback of DSA - Environment Setup :
------------------------------------------------------
*
*
*  

7) Examples of DSA - Environment Setup :
----------------------------------------
*
*
_______________________________________________________________________________
         
         *** Algorithm ***
             =========
               1. DSA - Algorithms Basics
               2. DSA - Asymptotic Analysis
               3. DSA - Greedy Algorithms
               4. DSA - Divide and Conquer
               5. DSA - Dynamic Programming

      <<<<<<<<< *** Algorithm *** >>>>>>>>>
                    =========
__________________________________________________
                                                  |
      Algorithm                                   |                  
__________________________________________________|
            |
            |
1) What's the Heading ?
-----------------------
* Algorithm
                                                                                        
2) Definition of Algorithm ?
----------------------------
*
 
3) What is Algorithm About ?
----------------------------
*
*

4) What does Algorithm Do ?
---------------------------
*
*

5) Advantages/Benefits of Algorithm :
-------------------------------------
*
*
*

6) Disadvantages/Drawback of Algorithm :
----------------------------------------
*
*
*  

7) Examples of Algorithm :
--------------------------
*
*
_______________________________________________________________________________

 1. <<<<<<<<< DSA - Algorithms Basics >>>>>>>>>

    From the data structure point of view, 
    following are some important categories of algorithms −
        
        a) Search - 
        b) Sort -
        c) Insert -
        d) Update -
        e) Delete - 

    ** Characteristics of an Algorithm 
       ````````````````````````````````
     Not all procedures can be called an algorithm.
   An algorithm should have the following characteristics −
               
           a) Unambiguous −
           b) Input −
           c) Output − 
           d) Finiteness −
           e) Feasibility −
           f) Independent − 
     
     ** How to Write an Algorithm ?
        `````````````````````````````
          = Example = 
            '''''''
             Let's try to learn "algorithm-writing" by using an example - 

          = Problem = − 
            '''''''
         'Design' an "algorithm" to add two numbers and display the result -
     
       ___________________________________________________
      |
      |  Step 1 − START
      |  Step 2 − declare three integers a, b & c
      |  Step 3 − define values of a & b
      |  Step 4 − add values of a & b
      |  Step 5 − store output of step 4 to c
      |  Step 6 − print c
      |  Step 7 − STOP
      |___________________________________________________ 
   
          * Algorithms tell the programmers how to code the program.
          * Alternatively, the algorithm can be written as −
  
      _____________________________________________________
     |
     |  Step 1 − START ADD
     |  Step 2 − get values of a & b
     |  Step 3 − c ← a + b
     |  Step 4 − display c
     |  Step 5 − STOP
     |_____________________________________________________ 
  
   ** In design and analysis of algorithms, usually the second method is
      used to describe an algorithm.
    * It makes it easy for the analyst to analyze the algorithm ignoring
      all unwanted definitions.
    * He can observe what operations are being used and how the
      process is flowing. 
       
        ** Writing "step numbers", is optional :
                    ''''''''''''
    ** We design an algorithm to get a solution of a given problem.
     * A problem can be solved in more than one ways.
         __________                       ___________
        (          )                     (           )  
        ( Solution )                     ( Solution  ) 
        (   #1     )                     (    #2     ) 
        (__________)                     (___________)
                   \                     /
                    \                   /
                     \                 / 
                      \_______________/
                      |               |
                      |               |
                      |    PROBLEM    | 
                      |               | 
                      |               |
                      |_______________|
                     /                 \
                    /                   \
                   /                     \
        __________/                       \__________          
       (          )                       (          )
       ( Solution )                       ( Solution )
       (    #4    )                       (    #3    )
       (__________)                       (__________)

   ** Hence, many solution algorithms can be derived for a given problem.
    * The next step is to analyze those proposed solution algorithms and
      implement the best suitable solution.
         
        *** Algorithm Analysis ***
            =-=-=-=-=-=-=-=-=- 
     ** Efficiency of an algorithm can be analyzed at two different stages,
        before implementation and after implementation :

                 a) A Priori Analysis -
                 b) A Posterior Analysis -
          
         *** Algorithm Complexity ***
             =-=-=-=-=-=-=-=-=-=-
      ** Suppose X is an algorithm and n is the size of input data,
         the time and space used by the algorithm X are the two main
         factors, 
         which decide the efficiency of X.

                 a) Time Factor -
                 b) Space Factor - 
      
          *** Space Complexity ***
              =-=-=-=-=-=-=-=-
   * Space required by an algorithm is equal to the sum of the following 
     two component -
                     + A Fixed Part -
                     + A Variable Part -

     ** Space complexity S(P) of any algorithm P is S(P) = C + SP(I),
        where C is the fixed part and S(I) is the variable part of the
        algorithm,
         which depends on instance characteristic I.
      * Following is a simple example that tries to explain the concept −
          ________________________________
         |  Algorithm: SUM(A, B)
         |  Step 1 -  START
         |  Step 2 -  C ← A + B + 10
         |  Step 3 -  Stop
         |________________________________

     ** Here we have three variables A, B, and C and one constant.
      * Hence S(P) = 1 + 3. 
      * Now, space depends on data types of given variables and 
        constant types and it will be multiplied accordingly.
          
           *** Time Complexity ***
               =-=-=-=-=-=-=-=
    ** Time complexity of an algorithm represents the amount of time
       required by the algorithm to run to completion.
__________________________________________________
                                                  |
       DSA - Algorithms Basics                    |                  
__________________________________________________|
            |
            |
1) What's the Heading ?
-----------------------
* DSA - Algorithms Basics
                                                                                        
2) Definition of DSA - Algorithms Basics ?
------------------------------------------
*
 
3) What is DSA - Algorithms Basics About ?
------------------------------------------
*
*

4) What does DSA - Algorithms Basics Do ?
-----------------------------------------
*
*

5) Advantages/Benefits of DSA - Algorithms Basics :
---------------------------------------------------
*
*
*

6) Disadvantages/Drawback of DSA - Algorithms Basics :
------------------------------------------------------
*
*
*  

7) Examples of DSA - Algorithms Basics :
----------------------------------------
*
*
_______________________________________________________________________________

 2. <<<<<<<<< DSA - Asymptotic Analysis >>>>>>>>>
 
    * Usually, the time required by an algorithm falls under three types −
          
       a) Best Case -
       b) Average Case -
       c) Worst Case -
             
            *** Asymptotic Notations ***
                =-=-=-=-=-=-=-=-=-=-
    -  the commonly used asymptotic notations to calculate the
       'running time complexity' of an 'algorithm'.
        '''''''''''''''''''''''         '''''''''
            a)  Ο Notation
            b)  Ω Notation
            c)  θ Notation
      
          *** Big Oh Notation, Ο ***
              =-=-=-=-=-=-=-=-=-
   - The notation Ο(n) is the formal way to express the upper bound of
     an algorithm's running time.
   - It measures the worst case time complexity or the longest amount 
     of time an algorithm can possibly take to complete. 


  
       ^            / g(n)    == f(n)
       |           /        ==
       |          /       ==
       |         /      ==
       |        /   ===
       |       /   ==
       |      /===
       |    ===
       |  ==/
       | ==/
       | =/
       |__|______________________________ >
          |
          |
          k  
      
       * For example, for a function f(n).
    __________________________________________________________________________________________ 
|
|  Ο(f(n)) = { g(n) : there exists c > 0 and n0 such that f(n) ≤ c.g(n) for all n > n0. }
|__________________________________________________________________________________________
      
        *** Omega Notation, Ω ***
            =================
    ** The notation Ω(n) is the formal way to express the lower bound of
       an algorithm's running time.
     * It measures the best case time complexity or the best amount of
       time an algorithm can possibly take to complete.


       ^
       |    
       |            
       |                                                ___________ f(n)
       |                                          _____/
       |                                         /                  - g(n)
       |                                        /                  -
       |                                       /                  -
       |                      ________________/                  -
       |                     /                               _ _-
       |                    /                  _ _ _ _ _-----
       |            _______/              _ _ -  
       |           /           _ _ _ _----
       |    ______/ _ _ _ _----  
       |---/-_ _ _--
       |  / |  
       |_/__|____________________________________________________________ >
            | 
            |
            k
 
         * For example, for a function f(n)
 __________________________________________________________________________________________
| 
|  Ω(f(n)) ≥ { g(n) : there exists c > 0 and n0 such that g(n) ≤ c.f(n) for all n > n0. }
|__________________________________________________________________________________________ 


        *** Theta Notation, θ ***
            =================
  ** The notation θ(n) is the formal way to express both the lower bound
     and the upper bound of an algorithm's running time.
   * It is represented as follows : 

       ^                                                        _--- g(n)
       |                                                    _ _-
       |                                         _ _--------
       |                                       _-        ___________ f(n)
       |                                     _-    _____/
       |                                    -    /                  - g(n)
       |                                  _-    /                  -
       |                     _ _ _ _ _ _ _     /                  -
       |                 _--- ________________/                  -
       |          _ _ _ _    /                               _ _-
       |         -          /                  _ _ _ _ _-----
       |        -   _______/              _ _ -  
       |     _ _   /           _ _ _ _----
       |-----_____/ _ _ _ _----  
       |   /-_ _ _--
       |--/ |  
       |_/__|____________________________________________________________ >
            | 
            |
            k
 _________________________________________________________________________________________
|
|  θ(f(n)) = { g(n) if and only if g(n) =  Ο(f(n)) and g(n) = Ω(f(n)) for all n > n0. }
|_________________________________________________________________________________________ 
     
      *** Common Asymptotic Notations ***
          =========================== 
    - Following is a list of some 'common asymptotic notations' −
                                   ```````````````````````````
 ___________________________________________________
|  constant     |     −      |        Ο(1)          |
|_______________|____________|______________________|
|  logarithmic  |     −      |        Ο(log n)      |
|_______________|____________|______________________|
|  linear       |     −      |        Ο(n)          |
|_______________|____________|______________________|
|  n log n      |     −      |        Ο(n log n)    |
|_______________|____________|______________________|
|  quadratic    |     −      |        Ο(n2)         |<< n to the power 2
|_______________|____________|______________________| 
|  cubic        |     −      |        Ο(n3)         |<< n  to the power 3
|_______________|____________|______________________|
|  polynomial   |     −      |        nΟ(1)         |<< n to the power O and 
|_______________|____________|______________________|
|  exponential  |     −      |        2Ο(n)         |<< 2 to the power O and n
|_______________|____________|______________________|
__________________________________________________
                                                  |
        DSA - Asymptotic Analysis                 |                  
__________________________________________________|
            |
            |
1) What's the Heading ?
-----------------------
* DSA - Asymptotic Analysis
                                                                                        
2) Definition of Asymptotic Analysis ?
--------------------------------------
*
 
3) What is Asymptotic Analysis About ?
--------------------------------------
*
*

4) What does Asymptotic Analysis Do ?
-------------------------------------
*
*

5) Advantages/Benefits of Asymptotic Analysis :
-----------------------------------------------
*
*
*

6) Disadvantages/Drawback of Asymptotic Analysis :
--------------------------------------------------
*
*
*  

7) Examples of Asymptotic Analysis :
------------------------------------
*
*
_______________________________________________________________________________

 3. <<<<<<<<< DSA - Greedy Algorithms >>>>>>>>>

       ** Counting Coins **
          =-=-=-=-=-=-=-

     1 − Select one ₹ 10 coin, the remaining count is 8

     2 − Then select one ₹ 5 coin, the remaining count is 3

     3 − Then select one ₹ 2 coin, the remaining count is 1
     
     4 − And finally, the selection of one ₹ 1 coins solves the problem
           
          Examples -
          ''''''''''''
       * Most networking algorithms use the greedy approach.  
         Here is a list of few of them −

             a) Travelling Salesman Problem
             b) Prim's Minimal Spanning Tree Algorithm
             c) Kruskal's Minimal Spanning Tree Algorithm
             d) Dijkstra's Minimal Spanning Tree Algorithm
             e) Graph - Map Coloring
             f) Graph - Vertex Cover
             g) Knapsack Problem
             h) Job Scheduling Problem

   * There are lots of similar problems that uses the greedy approach to
     find an optimum solution.
__________________________________________________
                                                  |
      DSA - Greedy Algorithms                     |                  
__________________________________________________|
            |
            |
1) What's the Heading ?
-----------------------
* DSA - Greedy Algorithms
                                                                                        
2) Definition of Greedy Algorithms ?
------------------------------------
*
 
3) What is Greedy Algorithms About ?
------------------------------------
*
*

4) What does Greedy Algorithms Do ?
-----------------------------------
*
*

5) Advantages/Benefits of Greedy Algorithms :
---------------------------------------------
*
*
*

6) Disadvantages/Drawback of Greedy Algorithms :
------------------------------------------------
*
*
*  

7) Examples of Greedy Algorithms :
----------------------------------
*
*
_______________________________________________________________________________

 4. <<<<<<<<< DSA - Divide and Conquer >>>>>>>>>
       ____________________________________________________
      |                                                    |
      |  a    b    c    d    e     f    g    h    i    j   |  Problem
      |____________________________________________________|
                   |           |             |
                   |           |             |
                   |           |             |
                   |           |             |     
        ___  ___  ___  ___  ___  ___  ___  ___  ___  ___
Divide | a || b || c || d || e || f || g || h || i || j |  Sub-Problem 
       |___||___||___||___||___||___||___||___||___||___|  
                   |           |             |
                   |           |             |
                   |           |             |
                   |           |             |     
         ___  ___  ___  ___  ___  ___  ___  ___  ___  ___
Conquer | A || B || C || D || E || F || G || H || I || J |  Sub-Solution 
        |___||___||___||___||___||___||___||___||___||___|
                    |          |             |
                    |          |             |
                    |          |             |
                    |          |             |      
       ____________________________________________________
Merge |  A    B    C    D    E     F    G    H    I    J   |  Solution 
      |____________________________________________________|

   
     * Broadly, we can understand divide-and-conquer approach in a
       three-step process :

                *** Divide/Break ***
                    =-=-=-=-=-=-
                
                *** Conquer/Solve ***
                    =-=-=-=-=-=-=
                 
                *** Merge/Combine ***
                    =-=-=-=-=-=-=
                       Examples -
                       ''''''''''''
     - The following computer algorithms are based on divide-and-conquer
       programming approach −
                  
              a) Merge Sort
              b) Quick Sort
              c) Binary Search
              d) Strassen's Matrix Multiplication
              e) Closest pair (points)
       
     - There are various ways available to solve any computer problem,
       but the mentioned are a good example of divide and conquer
       approach.
__________________________________________________
                                                  |
       DSA - Divide and Conquer                   |                  
__________________________________________________|
            |
            |
1) What's the Heading ?
-----------------------
* DSA - Divide and Conquer
                                                                                        
2) Definition of Divide and Conquer ?
-------------------------------------
*
 
3) What is Divide and Conquer About ?
-------------------------------------
*
*

4) What does Divide and Conquer Do ?
------------------------------------
*
*

5) Advantages/Benefits of Divide and Conquer :
----------------------------------------------
*
*
*

6) Disadvantages/Drawback of Divide and Conquer :
-------------------------------------------------
*
*
*  

7) Examples of Divide and Conquer :
-----------------------------------
*
*
________________________________________________________________________________

 5. <<<<<<<<< DSA - Dynamic Programming >>>>>>>>>

           *** Comparison :
                 
            ** Example -
      The following computer problems can be solved using dynamic
      programming approach -
                
          a) Fibonacci number series
          b) Knapsack problem
          c) Tower of Hanoi
          d) All pair shortest path by Floyd-Warshall
          e) Shortest path by Dijkstra
          f) Project scheduling

     ** Dynamic programming can be used in both top-down and bottom-up manner.
      * And of course, most of the times, referring to the previous solution
        output is cheaper than recomputing in terms of CPU cycles.
__________________________________________________
     DSA - Dynamic Programming                    |
                                                  |                  
__________________________________________________|
            |
            |
1) What's the Heading ?
-----------------------
* DSA - Dynamic Programming
                                                                                        
2) Definition of Dynamic Programming ?
--------------------------------------
*
 
3) What is Dynamic Programming About ?
--------------------------------------
*
*

4) What does Dynamic Programming Do ?
-------------------------------------
* 
*

5) Advantages/Benefits of Dynamic Programming :
-----------------------------------------------
*
*
*

6) Disadvantages/Drawback of Dynamic Programming :
--------------------------------------------------
*
*
*  

7) Examples of Dynamic Programming :
------------------------------------
*
*
_______________________________________________________________________________
 
        *** Data Structures ***
            ===============
              1. DSA - Data Structure Basics
              2. DSA - Array Data Structure

      <<<<<<<<< *** Data Structures *** >>>>>>>>>
                    ===============
__________________________________________________
                                                  |
    Data Structures                               |                  
__________________________________________________|
            |
            |
1) What's the Heading ?
-----------------------
* Data Structures
                                                                                        
2) Definition of Data Structures ?
----------------------------------
*
 
3) What is Data Structures About ?
----------------------------------
*
*

4) What does Data Structures Do ?
---------------------------------
*
*

5) Advantages/Benefits of Data Structures :
-------------------------------------------
*
*
*

6) Disadvantages/Drawback of Data Structures :
----------------------------------------------
*
*
*  

7) Examples of Data Structures :
--------------------------------
*
*
_______________________________________________________________________________

 1. <<<<<<<<< DSA - Data Structure Basics >>>>>>>>>

     ** Data Definition -
        ``````````````````
           Data Definition defines a particular data with the following
           characteristics.

        a) Atomic - Definition should define a single concept.
           ''''''
        b) Traceable − Definition should be able to be mapped to some
           '''''''''   data element. 
          
        c) Accurate − Definition should be unambiguous.
           ''''''''
        d) Clear and Concise − Definition should be understandable.
           '''''''''''''''''
        
     ** Data Object -
        ```````````````
         Data Object represents an object having a data.
      
     ** Data Type -
        ````````````
           There are two data types −

         a)  Built-in Data Type :
             '''''''''''''''''''''
         b)  Derived Data Type :
             ''''''''''''''''''''

         a)  ** Built-in Data Type ** :
                ''''''''''''''''''
                   1) Integers
                   2) Boolean (true, false)
                   3) Floating (Decimal numbers)
                   4) Character and Strings

         b)  ** Derived Data Type *** :
                '''''''''''''''''
                   1) List
                   2) Array
                   3) Stack
                   4) Queue
            
              *** Basic Operations -
                  ````````````````````
                    1) Traversing
                    2) Searching
                    3) Insertion
                    4) Deletion
                    5) Sorting
                    6) Merging
__________________________________________________
                                                  |
     DSA - Data Structure Basics                  |                  
__________________________________________________|
            |
            |
1) What's the Heading ?
-----------------------
* DSA - Data Structure Basics
                                                                                        
2) Definition of Data Structure Basics ?
----------------------------------------
*
 
3) What is Data Structure Basics About ?
----------------------------------------
*
*

4) What does Data Structure Basics Do ?
---------------------------------------
*
*

5) Advantages/Benefits of Data Structure Basics :
-------------------------------------------------
*
*
*

6) Disadvantages/Drawback of Data Structure Basics :
----------------------------------------------------
*
*
*  

7) Examples of Data Structure Basics :
--------------------------------------
*
*
_______________________________________________________________________________

 2. <<<<<<<<< DSA - Array Data Structure >>>>>>>>>
    
        - important terms to understand the concept of Array :

      a) Element − Each item stored in an array is called an element.
         '''''''
      b) Index − Each location of an element in an array has a numerical
         '''''   index, which is used to identify the element.
    
            *** Array Representation -
                ````````````````````````
         Arrays can be declared in various ways in different languages. 
         For illustration, let's take C array declaration :
  _______________________________________________________________________

           Name                       	Elements 
            | 
            v            "`````````````````````````````````````"
      int array [10] = { 35, 33, 42, 10, 14, 19, 27, 44, 26, 31 }
       ^          ^
       |          |
      Type       Size 
  _______________________________________________________________________
           
         Arrays can be declared in various ways in different languages.
         For illustration, let's take C array declaration :
 ____________________________________________________________________________
     
           ____  ____  ____  ____  ____  ____  ____  ____  ____  ____ 
 elements | 35 || 33 || 42 || 10 || 14 || 19 || 27 || 44 || 26 || 31 |  
          |____||____||____||____||____||____||____||____||____||____|
   
 index      0     1     2     3     4     5     6     7     8     9     
       
           "`````````````````````````````````````````````````````````"
                                 Size :10
 _____________________________________________________________________________

       * important points to be considered -
             
            a) Index starts with 0.

            b) Array length is 10 which means it can store 10 elements.
 
            c) Each element can be accessed via its index.
               For example, we can fetch an element at index 6 as 9.
         
         *** Basic Operations -
             ````````````````````
             Following are the basic operations supported by an array :
          
     a) Traverse − print all the array elements one by one.

     b) Insertion − Adds an element at the given index.

     c) Deletion − Deletes an element at the given index.

     d) Search − Searches an element using the given index or by the value.

     e) Update − Updates an element at the given index.
         
   * In C, when an 'array' is 'initialized with size', then it assigns defaults
     values to its elements in following order.
             
 ______________________________________________________________
|        Data Type              |       Default Value          |
|```````````````````````````````|``````````````````````````````|
|_______________________________|______________________________|
|       bool                    |	  false                |
|_______________________________|______________________________|
|       char                    |           0                  |
|_______________________________|______________________________|
|        int                    |           0                  |
|_______________________________|______________________________|
|       float                   |          0.0                 |
|_______________________________|______________________________|
|      double                   |          0.0f                |
|_______________________________|______________________________|
|        void                   |                              |
|_______________________________|______________________________|
|      wchar_t                  |           0                  |
|_______________________________|______________________________|
  
     ** Traverse Operation -
        ``````````````````````
        This operation is to traverse through the elements of an array.
         
          Example -
          ''''''''''
          Following program traverses and prints the elements of an array:
    ______________________________________________________
   |  #include <stdio.h>
   |  main() {
   |     int LA[] = {1,3,5,7,8};
   |     int item = 10, k = 3, n = 5;
   |     int i = 0, j = n;   
   |     printf("The original array elements are :\n");
   |     for(i = 0; i<n; i++) {
   |        printf("LA[%d] = %d \n", i, LA[i]);
   |     }
   |  }
   |________________________________________________________ 
     
      When we compile and execute the above program, it produces the
      results -
  
       Output - 
    ____________________________________
   |  The original array elements are :
   |  LA[0] = 1 
   |  LA[1] = 3 
   |  LA[2] = 5 
   |  LA[3] = 7 
   |  LA[4] = 8 
   |_____________________________________

       ** Insertion Operation -
          ```````````````````````
          Example -
          '''''''
      Following is the implementation of the above algorithm −
    _______________________________________________________________
   |  #include <stdio.h>
   |
   |  main() {
   |     int LA[] = {1,3,5,7,8};
   |     int item = 10, k = 3, n = 5;
   |     int i = 0, j = n;
   | 
   |     printf("The original array elements are :\n");
   |
   |     for(i = 0; i<n; i++) {
   |        printf("LA[%d] = %d \n", i, LA[i]);
   |     }
   |
   |     n = n + 1;
   |	
   |     while( j >= k) {
   |        LA[j+1] = LA[j];
   |        j = j - 1;
   |     }
   | 
   |     LA[k] = item;
   |
   |     printf("The array elements after insertion :\n");
   |
   |     for(i = 0; i<n; i++) {
   |        printf("LA[%d] = %d \n", i, LA[i]);
   |     }
   |  }
   |______________________________________________________________________

     - When we compile and execute the above program, it produces the
       results -
        
         Output -
    _________________________________________________
   |  The original array elements are :
   |  LA[0] = 1 
   |  LA[1] = 3 
   |  LA[2] = 5 
   |  LA[3] = 7 
   |  LA[4] = 8 
   |  The array elements after insertion :
   |  LA[0] = 1 
   |  LA[1] = 3 
   |  LA[2] = 5 
   |  LA[3] = 10 
   |  LA[4] = 7 
   |  LA[5] = 8
   |_____________________________________________________ 
  
     ** Deletion Operation -
        ``````````````````````
        Deletion refers to removing an existing element from the array and
        re-organizing all elements of an array.
         
         a) Algorithm -
            '''''''''
           * Consider LA is a linear array with N elements and K is a positive
             integer such that K<=N. 
           * Following is the algorithm to delete an element available at the
             Kth position of LA.
     ________________________________________________
    |  1. Start
    |  2. Set J = K
    |  3. Repeat steps 4 and 5 while J < N
    |  4. Set LA[J] = LA[J + 1]
    |  5. Set J = J+1
    |  6. Set N = N-1
    |  7. Stop
    |_________________________________________________
 
         Example -                         ^
         '''''''''''                       ^
         * Following is the "implementation of the above algorithm" −
   ____________________________________________________________________
  |  #include <stdio.h>
  |
  |  void main() {
  |     int LA[] = {1,3,5,7,8};
  |     int k = 3, n = 5;
  |     int i, j;
  | 
  |     printf("The original array elements are :\n");
  |	
  |     for(i = 0; i<n; i++) {
  |        printf("LA[%d] = %d \n", i, LA[i]);
  |     }
  |  
  |     j = k;
  |	
  |     while( j < n) {
  |        LA[j-1] = LA[j];
  |        j = j + 1;
  |     }
  |	
  |     n = n -1;
  | 
  |     printf("The array elements after deletion :\n");
  |	
  |     for(i = 0; i<n; i++) {
  |        printf("LA[%d] = %d \n", i, LA[i]);
  |     }
  |  }
  |_______________________________________________________________________ 
             
    * When we compile and execute the above program, it produces the
      results -
   
        Output -
    __________________________________________________
   |  The original array elements are :
   |  LA[0] = 1 
   |  LA[1] = 3 
   |  LA[2] = 5 
   |  LA[3] = 7 
   |  LA[4] = 8 
   |  The array elements after deletion :
   |  LA[0] = 1 
   |  LA[1] = 3 
   |  LA[2] = 7 
   |  LA[3] = 8 
   |___________________________________________________
        
         ** Search Operation -
            ````````````````````
        You can perform a search for an array element based on its value
        or it's index -
  
         a) Algorithm -
            '''''''''
     * Consider "LA" is a linear array with "N" elements and "K" is a positive
       integer such that "K<=N".
     * Following is the algorithm to find an element with a value of 
       ITEM using sequential search.
     _________________________________________________
    |  1. Start
    |  2. Set J = 0
    |  3. Repeat steps 4 and 5 while J < N
    |  4. IF LA[J] is equal ITEM THEN GOTO STEP 6
    |  5. Set J = J +1
    |  6. PRINT J, ITEM
    |  7. Stop
    \_________________________________________________
 
          Example -
          '''''''
          Following is the implementation of the above algorithm −
     _____________________________________________________________________
    |  #include <stdio.h>
    |
    |  void main() {
    |     int LA[] = {1,3,5,7,8};
    |     int item = 5, n = 5;
    |     int i = 0, j = 0;
    |
    |     printf("The original array elements are :\n");
    |	
    |     for(i = 0; i<n; i++) {
    |        printf("LA[%d] = %d \n", i, LA[i]);
    |     }
    | 
    |     while( j < n){
    |        if( LA[j] == item ) {
    |           break;
    |        }
    |		
    |        j = j + 1;
    |     }
    |	
    |     printf("Found element %d at position %d\n", item, j+1);
    |  }
    |________________________________________________________________________

       * When we compile and execute the above program, it produces the
         results -
           
            Output -
     ___________________________________________________
    |  The original array elements are :
    |  LA[0] = 1 
    |  LA[1] = 3 
    |  LA[2] = 5 
    |  LA[3] = 7 
    |  LA[4] = 8 
    |  Found element 5 at position 3
    |__________________________________________________

         ** Update Operation -
            ````````````````````
            Update operation refers to updating an existing element from the
            array at a given index.
          
             Algorithm -
             '''''''''''''
       Consider "LA" is a linear array with "N" elements and "K" is a positive
       integer such that "K<=N".
       
       Following is the algorithm to update an element available at
       the Kth position of LA.
         ________________________________
        |  1. Start
        |  2. Set LA[K-1] = ITEM
        |  3. Stop
        |_________________________________
   
            Example -
            '''''''
         Following is the implementation of the above algorithm −

   ________________________________________________________________________
  |  #include <stdio.h>
  |
  |  void main() {
  |     int LA[] = {1,3,5,7,8};
  |     int k = 3, n = 5, item = 10;
  |     int i, j;
  | 
  |     printf("The original array elements are :\n");
  |	
  |     for(i = 0; i<n; i++) {
  |        printf("LA[%d] = %d \n", i, LA[i]);
  |     }
  |  
  |     LA[k-1] = item;
  |
  |     printf("The array elements after updation :\n");
  |	
  |     for(i = 0; i<n; i++) {
  |        printf("LA[%d] = %d \n", i, LA[i]);
  |     }
  |  }
  |_____________________________________________________________________ 
  
      - When we compile and execute the above program, it produces the 
        result -
  
          Output -
    ________________________________________________
   |  The original array elements are :
   |  LA[0] = 1 
   |  LA[1] = 3  
   |  LA[2] = 5 
   |  LA[3] = 7 
   |  LA[4] = 8 
   |  The array elements after updation :
   |  LA[0] = 1 
   |  LA[1] = 3 
   |  LA[2] = 10 
   |  LA[3] = 7 
   |  LA[4] = 8
   |_________________________________________________
__________________________________________________
                                                  |
      DSA - Array Data Structure                  |                  
__________________________________________________|
            |
            |
1) What's the Heading ?
-----------------------
* DSA - Array Data Structure
                                                                                        
2) Definition of Array Data Structure ?
---------------------------------------
*
 
3) What is Array Data Structure About ?
---------------------------------------
*
*

4) What does Array Data Structure Do ?
--------------------------------------
*
*

5) Advantages/Benefits of Array Data Structure :
------------------------------------------------
*
*
*

6) Disadvantages/Drawback of Array Data Structure :
---------------------------------------------------
*
*
*  

7) Examples of Array Data Structure :
-------------------------------------
*
*
_______________________________________________________________________________
   
        *** Linked Lists ***
            ============
              1. DSA - Linked List Basics
              2. DSA - Doubly Linked List
              3. DSA - Circular Linked List

      <<<<<<<<< *** Linked Lists *** >>>>>>>>>
                    ============
__________________________________________________
                                                  |
      Linked Lists                                |                  
__________________________________________________|
            |
            |
1) What's the Heading ?
-----------------------
* Linked Lists
                                                                                        
2) Definition of Linked Lists ?
-------------------------------
*
 
3) What is Linked Lists About ?
-------------------------------
*
*

4) What does Linked Lists Do ?
------------------------------
*
*

5) Advantages/Benefits of Linked Lists :
----------------------------------------
*
*
*

6) Disadvantages/Drawback of Linked Lists :
-------------------------------------------
*
*
*  

7) Examples of Linked Lists :
-----------------------------
*
*
_______________________________________________________________________________

 1. <<<<<<<<< DSA - Linked List Basics >>>>>>>>>
   
    -  important terms to understand the concept of Linked List.
           a) Link -
           b) Next -
           c) LinkedList -

         ** Linked List Representation -
            ==========================
   * Linked list can be visualized as a chain of nodes, where every node
     points to the next node.
                  
                   NODE                          NODE
   ________       _______________________      ________________________
  || Head ||     ||             || Next ||    ||             || Next  ||
  ||  ()--||-->  || Dated Items ||  ()--||--> || Dated Items ||  ()   ||
  ||______||     ||_____________||______||    ||_____________||_/_____||
                                                               / 
                                                 NODE         /     
                                               ______________v_________    
                                              ||             || Next  ||
                                              || Dated Items ||  ()---||---
                                              ||_____________||_______||  |  /|
                                                                          | / |
                                                                          V/| |
                                                                          / | | 
                                                                         /| | |
                                                                           NULL

  * As per the above illustration, following are the important points 
    to be considered. 
      
        a) Linked List contains a link element called first.

        b) Each link carries a data field(s) and a link field called next.

        c) Each link is linked with its next link using its next link.

        d) Last link carries a link as null to mark the end of the list.

  
      *** Types of Linked List :
          ======================
    * Following are the various "types of linked list" :
            
          a) Simply Linked List -
          b) Doubly Linked List -
          c) Circular Linked List -
  
      *** Basic Operations :
          ================
   * Following are the basic operations supported by a list :
           
     a) "Insertion" − Adds an element at the beginning of the list.
         '''''''''
     b) "Deletion" − Deletes an element at the beginning of the list.
         ''''''''
     c) "Display" − Displays the complete list.
         '''''''
     d) "Search" − Searches an element using the given key.
         ''''''
     e) "Delete" − Deletes an element using the given key.
         ''''''

        *** Insertion Operation :
            ===================
   * Adding a new node in linked list is a more than one step activity.
     We shall learn this with diagrams here. 
   * First, create a node using the same structure and find the 
     location where it has to be inserted. 
 
                 NODE                                NODE
 ________     _______________________             ________________________
|| Head ||   ||             || Next ||           ||             || Next  ||
||  ()--||-->|| Dated Items ||  ()--||---------->|| Dated Items ||  ()---||----
||______||   ||_____________||______||           ||_____________||_______||   |
                                                                              | /
                                                                              V/|
                                                                              /||
                                                                             /|||
                                                                            NULL
                                                                                                            ________________________    
                         ||             || Next  ||
                         || Dated Items ||  ()   ||
                         ||_____________||_______|| 
                             New NODE
  
   * Imagine that we are inserting a node B (NewNode), between "A"
     (LeftNode) and C (RightNode). 
   * Then point B.next to C −
      ___________________________________
     |  NewNode.next −> RightNode;       |
     |___________________________________|
 
    - It should look like this −

                    NODE                                NODE
 ________     _______________________             ________________________
|| Head ||   ||             || Next ||           ||             || Next  ||
||  ()--||-->|| Dated Items ||  ()--||---------->|| Dated Items ||  ()---||----
||______||   ||_____________||______||    ------>||_____________||_______||   |
                                          |                                   | /
                                          |                                   V/|
                                          |                                   /||
                                          |                                  /|||
                                          |                                 NULL
                                          |                                                    ________________________     |
            ||             || Next  ||    |
            || Dated Items ||  ()---||-----
            ||_____________||_______|| 
                      New NODE


  * Now, the next node at the left should point to the new node.

                        NODE                                NODE
 ________     _______________________             ________________________
|| Head ||   ||             || Next ||   /------>||             || Next  ||
||  ()--||-->|| Dated Items ||  ()--||--/        || Dated Items ||  ()---||----
||______||   ||_____________||______||  | ------>||_____________||_______||   |
                                        | |                                   | /
                                        | |                                   V/|
                                        | |                                   /||
                                        | |                                  /|||
        --------------------------------  |                                 NULL
       |                                  |                                              |     ________________________     |
       |    ||             || Next  ||    |
       ---->|| Dated Items ||  ()---||-----
            ||_____________||_______|| 
                      New NODE
   
   * This will put the new node in the middle of the two.
   * The new list should look like this −


 ________     ____________________     ___________________      ________________
|| Head ||   ||           ||Next ||   ||           ||Next ||   |           |Next|
||  ()--||-->||Dated Items|| ()--||-->||Dated Items|| ()--||-->|Dated Items| () |
||______||   ||___________||_____||   ||___________||_____||   |___________|_|__|
                                                                             |
                                                                             | /
                                                                             V/|
                                                                             /||
                                                                            /|||
                                                                            NULL

        ** Deletion Operation :
           ==================
         
        ** Reverse Operation :
           =================

__________________________________________________
                                                  |
      DSA - Linked List Basics                    |                  
__________________________________________________|
            |
            |
1) What's the Heading ?
-----------------------
* DSA - Linked List Basics
                                                                                        
2) Definition of Linked List Basics ?
-------------------------------------
*
 
3) What is Linked List Basics About ?
-------------------------------------
*
*

4) What does Linked List Basics Do ?
------------------------------------
*
*

5) Advantages/Benefits of Linked List Basics :
----------------------------------------------
*
*
*

6) Disadvantages/Drawback of Linked List Basics :
-------------------------------------------------
*
*
*  

7) Examples of Linked List Basics :
-----------------------------------
*
*
_______________________________________________________________________________

 2. <<<<<<<<< DSA - Doubly Linked List >>>>>>>>>
    
  -  important terms to understand the concept of doubly linked list :
          
         a) Link -
         b) Next -
         c) Prev -
         d) LinkedList -
                
      ** Doubly Linked List Representation :
         =================================
     
      ** Basic Operations :
         ================
   Following are the basic operations supported by a list. 
           
      a) Insertion − Adds an element at the beginning of the list.
         '''''''''
      b) Deletion − Deletes an element at the beginning of the list.
         ''''''''
      c) Insert Last − Adds an element at the end of the list.
         '''''''''''
      d) Delete Last − Deletes an element from the end of the list.
         '''''''''''
      e) Insert After − Adds an element after an item of the list.
         ''''''''''''
      f) Delete − Deletes an element from the list using the key.
         ''''''
      g) Display forward − Displays the complete list in a forward manner.
         '''''''''''''''
      h) Display backward − Displays the complete list in a backward manner.
         ''''''''''''''''
            
        ** Insertion Operation :
           ===================
   - Following code demonstrates the insertion operation at the
     beginning of a doubly linked list.
       
      Example :
      '''''''''''
    ________________________________________________________________________
   |  //insert link at the first location
   |  void insertFirst(int key, int data) {
   |
   |     //create a link
   |     struct node *link = (struct node*) malloc(sizeof(struct node));
   |     link->key = key;
   |     link->data = data;
   |	
   |     if(isEmpty()) {
   |        //make it the last link
   |        last = link;
   |     } else {
   |        //update first prev link
   |        head->prev = link;
   |     }
   |
   |     //point it to old first link
   |     link->next = head;
   |	
   |    //point first to new first link
   |    head = link;
   |  }
   |__________________________________________________________________________

       ** Deletion Operation :
          ==================
    Following code demonstrates the deletion operation at the
    beginning of a doubly linked list -
        
           Example -
           ''''''''''
    _____________________________________________________________
   |  //delete first item
   |  struct node* deleteFirst() {
   |
   |     //save reference to first link
   |     struct node *tempLink = head;
   |	
   |    //if only one link
   |    if(head->next == NULL) {
   |       last = NULL;
   |    } else {
   |       head->next->prev = NULL;
   |    }
   |	 
   |    head = head->next;
   |	  
   |    //return the deleted link
   |    return tempLink;
   |  }
   |________________________________________________________________

       ** Insertion at the End of an Operation :
          ====================================
  
             Example -
             '''''''
    ________________________________________________________________________
   |  //insert link at the last location
   |  void insertLast(int key, int data) {
   |
   |     //create a link
   |     struct node *link = (struct node*) malloc(sizeof(struct node));
   |     link->key = key;
   |     link->data = data;
   |	
   |     if(isEmpty()) {
   |        //make it the last link
   |        last = link;
   |     } else {
   |        //make link a new last link
   |        last->next = link;     
   |    
   |       //mark old last node as prev of new link
   |       link->prev = last;
   |     }
   |
   |     //point last to new last node
   |     last = link;
   |  }
   |_________________________________________________________________________

     * To see the implementation in "C programming language", Look it
       Up -
               " Doubly Linked List Program in C "
                 '''''''''''''''''''''''''''''''
         Implementation in C
 _____________________________________________________________________________
|  #include <stdio.h>
|  #include <string.h>
|  #include <stdlib.h>
|  #include <stdbool.h>
|
|  struct node {
|     int data;
|     int key;
|  	
|     struct node *next;
|     struct node *prev;
|  };
|
|  //this link always point to first Link
|  struct node *head = NULL;
|
|  //this link always point to last Link 
|  struct node *last = NULL;
|
|  struct node *current = NULL;
|
|  //is list empty
|  bool isEmpty() {
|     return head == NULL;
|  }
|
|  int length() {
|     int length = 0;
|     struct node *current;
|  	
|     for(current = head; current != NULL; current = current->next){
|        length++;
|     }
|  	
|     return length;
|  }
|  
|  //display the list in from first to last
|  void displayForward() {
|  
|     //start from the beginning
|     struct node *ptr = head;
|  	
|     //navigate till the end of the list
|     printf("\n[ ");
|  	
|     while(ptr != NULL) {        
|        printf("(%d,%d) ",ptr->key,ptr->data);
|        ptr = ptr->next;
|     }
|	
|     printf(" ]");
|  }
|
|  //display the list from last to first
|  void displayBackward() {
|
|     //start from the last
|     struct node *ptr = last;
|	
|     //navigate till the start of the list
|     printf("\n[ ");
|  	
|     while(ptr != NULL) {    
|  	
|        //print data
|        printf("(%d,%d) ",ptr->key,ptr->data);
|  		
|        //move to next item
|        ptr = ptr ->prev;
|        
|     }
|	
|  }
|
|  //insert link at the first location
|  void insertFirst(int key, int data) {
|  
|     //create a link
|     struct node *link = (struct node*) malloc(sizeof(struct node));
|     link->key = key;
|     link->data = data;
|  	
|     if(isEmpty()) {
|        //make it the last link
|        last = link;
|     } else {
|        //update first prev link
|        head->prev = link;
|     }
|
|     //point it to old first link
|     link->next = head;
|  	
|     //point first to new first link
|     head = link;
|  }
|
|  //insert link at the last location
|  void insertLast(int key, int data) {
|
|     //create a link
|     struct node *link = (struct node*) malloc(sizeof(struct node));
|     link->key = key;
|     link->data = data;
|	
|     if(isEmpty()) {
|        //make it the last link
|        last = link;
|     } else {
|        //make link a new last link
|        last->next = link;     
|        
|        //mark old last node as prev of new link
|        link->prev = last;
|     }
|
|     //point last to new last node
|     last = link;
|  }
|  
|  //delete first item
|  struct node* deleteFirst() {
|
|     //save reference to first link
|     struct node *tempLink = head;
|  	
|     //if only one link
|     if(head->next == NULL){
|        last = NULL;
|     } else {
|        head->next->prev = NULL;
|     }
|	
|     head = head->next;
|     //return the deleted link
|     return tempLink;
|  }
|
|  //delete link at the last location
|
|  struct node* deleteLast() {
|     //save reference to last link
|     struct node *tempLink = last;
|  	
|     //if only one link
|     if(head->next == NULL) {
|        head = NULL;
|     } else {
|        last->prev->next = NULL;
|     }
|  	
|     last = last->prev;
|  	
|     //return the deleted link
|     return tempLink;
|  }
|
|  //delete a link with given key
|
|  struct node* delete(int key) {
|
|     //start from the first link
|     struct node* current = head;
|     struct node* previous = NULL;
|	
|     //if list is empty
|     if(head == NULL) {
|        return NULL;
|     }
|
|     //navigate through list
|     while(current->key != key) {
|        //if it is last node
|  		
|        if(current->next == NULL) {
|           return NULL;
|        } else {
|           //store reference to current link
|           previous = current;
|  			
|           //move to next link
|           current = current->next;             
|        }
|     }
|
|     //found a match, update the link
|     if(current == head) {
|        //change first to point to next link
|        head = head->next;
|     } else {
|        //bypass the current link
|        current->prev->next = current->next;
|     }    
| 
|     if(current == last) {
|        //change last to point to prev link
|        last = current->prev;
|     } else {
|        current->next->prev = current->prev;
|     }
|  	
|     return current;
|  }
|
|  bool insertAfter(int key, int newKey, int data) {
|     //start from the first link
|     struct node *current = head; 
|	
|     //if list is empty
|     if(head == NULL) {
|        return false;
|     }
|
|     //navigate through list
|     while(current->key != key) {
|  	
|        //if it is last node
|        if(current->next == NULL) {
|           return false;
|        } else {           
|           //move to next link
|           current = current->next;
|        }
|     }
|  	
|     //create a link
|     struct node *newLink = (struct node*) malloc(sizeof(struct node));
|     newLink->key = newKey;
|     newLink->data = data;
|
|     if(current == last) {
|        newLink->next = NULL; 
|        last = newLink; 
|     } else {
|        newLink->next = current->next;         
|        current->next->prev = newLink;
|     }
|	
|     newLink->prev = current; 
|     current->next = newLink; 
|     return true; 
|  }
|
|  void main() {
|     insertFirst(1,10);
|     insertFirst(2,20);
|     insertFirst(3,30);
|     insertFirst(4,1);
|     insertFirst(5,40);
|     insertFirst(6,56); 
|  
|     printf("\nList (First to Last): ");  
|     displayForward();
|  	
|     printf("\n");
|     printf("\nList (Last to first): "); 
|     displayBackward();
|  
|     printf("\nList , after deleting first record: ");
|     deleteFirst();        
|     displayForward();
|  
|     printf("\nList , after deleting last record: ");  
|     deleteLast();
|     displayForward();
|
|     printf("\nList , insert after key(4) : ");  
|     insertAfter(4,7, 13);
|     displayForward();
|  
|     printf("\nList  , after delete key(4) : ");  
|     delete(4);
|     displayForward();
|  }
|__________________________________________________________________________ 

    * If we compile and run the above program, it will produce the
      result -

        OUTPUT : 
    ________________________________________________________________
   |  List (First to Last): 
   |  [ (6,56) (5,40) (4,1) (3,30) (2,20) (1,10) ]
   |
   |  List (Last to first): 
   |  [ (1,10) (2,20) (3,30) (4,1) (5,40) (6,56) ]
   |  List , after deleting first record: 
   |  [ (5,40) (4,1) (3,30) (2,20) (1,10) ]
   |  List , after deleting last record: 
   |  [ (5,40) (4,1) (3,30) (2,20) ]
   |  List , insert after key(4) : 
   |  [ (5,40) (4,1) (7,13) (3,30) (2,20) ]
   |  List , after delete key(4) : 
   |  [ (5,40) (4,13) (3,30) (2,20) ] 
   |__________________________________________________________________
__________________________________________________
                                                  |
      DSA - Doubly Linked List                    |                  
__________________________________________________|
            |
            |
1) What's the Heading ?
-----------------------
* DSA - Doubly Linked List
                                                                                        
2) Definition of Doubly Linked List ?
-------------------------------------
*
 
3) What is Doubly Linked List About ?
-------------------------------------
*
*

4) What does Doubly Linked List Do ?
------------------------------------
*
*

5) Advantages/Benefits of Doubly Linked List :
----------------------------------------------
*
*
*

6) Disadvantages/Drawback of Doubly Linked List :
-------------------------------------------------
*
*
*  

7) Examples of Doubly Linked List :
-----------------------------------
*
*
_______________________________________________________________________________

 3. <<<<<<<<< DSA - Circular Linked List >>>>>>>>>

    ** Singly Linked List as Circular :
       ==============================

    ** Doubly Linked List as Circular :
       ==============================
        
    ** Basic Operations :
       ================
   + Following are the important operations supported by a circular list -
        
        a) insert − Inserts an element at the start of the list.
           ''''''
        b) delete − Deletes an element from the start of the list.
           ''''''
        c) display − Displays the list.
           '''''''
        
    ** Insertion Operation :
       ===================
   + Following code demonstrates the insertion operation in a circular
     linked list based on single linked list -
         
         Example -
         '''''''
    ______________________________________________________
   |  insertFirst(data):
   |  Begin
   |     create a new node
   |     node -> data := data
   |     if the list is empty, then
   |        head := node
   |        next of node = head
   |     else
   |        temp := head
   |        while next of temp is not head, do
   |        temp := next of temp
   |        done
   |        next of node := head
   |        next of temp := node
   |        head := node
   |     end if
   |  End
   |_______________________________________________________
        
     ** Deletion Operation :
        ==================
   + Following code demonstrates the deletion operation in a circular
     linked list based on single linked list -
    ___________________________________________________
   |  deleteFirst():
   |  Begin
   |     if head is null, then
   |        it is Underflow and return
   |     else if next of head = head, then
   |        head := null
   |        deallocate head
   |     else
   |        ptr := head
   |        while next of ptr is not head, do
   |           ptr := next of ptr
   |        next of ptr = next of head
   |        deallocate head
   |        head := next of ptr
   |     end if
   |  End
   |____________________________________________________ 
 
      ** Display List Operation :
         ======================
     + Following code demonstrates the display list operation in a circular
       linked list -
    ___________________________________________________
   |  display():
   |  Begin
   |     if head is null, then
   |        Nothing to print and return
   |     else
   |        ptr := head
   |        while next of ptr is not head, do
   |           display data of ptr
   |           ptr := next of ptr
   |        display data of ptr
   |     end if
   |  End
   |____________________________________________________
 
      ** Display List Operation :
         ======================
   + Following code demonstrates the display list operation in a circular
     linked list -
    ____________________________________________________
   |   display():
   |   Begin
   |      if head is null, then
   |         Nothing to print and return
   |      else
   |         ptr := head
   |         while next of ptr is not head, do
   |            display data of ptr
   |            ptr := next of ptr
   |         display data of ptr
   |      end if
   |   End 
   |_____________________________________________________

     
    - To know about its implementation in C programming language,
      *** Circular Linked List Program in C -
          '''''''''''''''''''''''''''''''''     
           * Implementation in C -
             '''''''''''''''''''
____________________________________________________________________________
|
| #include <stdio.h>
| #include <string.h>
| #include <stdlib.h>
| #include <stdbool.h>
|
| struct node {
|    int data;
|    int key;
|	
|    struct node *next;
| };
|
| struct node *head = NULL;
| struct node *current = NULL;
| 
| bool isEmpty() {
|    return head == NULL;
| }
|
| int length() {
|    int length = 0;
|
|    //if list is empty
|    if(head == NULL) {
|       return 0;
|    }
|
|    current = head->next;
| 
|    while(current != head) {
|       length++;
|       current = current->next;   
|    }
| 	
|    return length;
| }
|
| //insert link at the first location
| void insertFirst(int key, int data) {
|
|    //create a link
|     struct node *link = (struct node*) malloc(sizeof(struct node));
|    link->key = key;
|    link->data = data;
|	
|    if (isEmpty()) {
|       head = link;
|       head->next = head;
|    } else {
|       //point it to old first node
|       link->next = head;
|		
|       //point first to new first node
|       head = link;
|    }    
| }
|
| //delete first item
| struct node * deleteFirst() {
|
|    //save reference to first link
|    struct node *tempLink = head;
| 	
|    if(head->next == head) {  
|       head = NULL;
|       return tempLink;
|    }     
|
|    //mark next to first link as first 
|    head = head->next;
|	
|    //return the deleted link
|    return tempLink;
| }
|
| //display the list
| void printList() {
|
|    struct node *ptr = head;
|    printf("\n[ ");
| 	
|    //start from the beginning
|    if(head != NULL) {
| 	
|       while(ptr->next != ptr) {     
|          printf("(%d,%d) ",ptr->key,ptr->data);
|          ptr = ptr->next;
|       }
|    }
| 	
|    printf(" ]");
| }
| 
| void main() {
|    insertFirst(1,10);
|    insertFirst(2,20);
|    insertFirst(3,30);
|    insertFirst(4,1);
|    insertFirst(5,40);
|    insertFirst(6,56); 
|
|    printf("Original List: "); 
|	
|    //print list
|    printList();
|
|    while(!isEmpty()) {            
|       struct node *temp = deleteFirst();
|       printf("\nDeleted value:");  
|       printf("(%d,%d) ",temp->key,temp->data);
|    }   
|	
|    printf("\nList after deleting all items: ");
|    printList();   
| }
|____________________________________________________________________________

   * If we compile and run the above program, it will produce the
     result -

       Output -
   ____________________________________________________
  |  Original List: 
  |  [ (6,56) (5,40) (4,1) (3,30) (2,20) ]
  |  Deleted value:(6,56) 
  |  Deleted value:(5,40) 
  |  Deleted value:(4,1) 
  |  Deleted value:(3,30) 
  |  Deleted value:(2,20) 
  |  Deleted value:(1,10) 
  |  List after deleting all items: 
  |  [ ]
  |_____________________________________________________
__________________________________________________
                                                  |
     DSA - Circular Linked List                   |                  
__________________________________________________|
            |
            |
1) What's the Heading ?
-----------------------
* DSA - Circular Linked List
                                                                                        
2) Definition of Circular Linked List ?
---------------------------------------
*
 
3) What is Circular Linked List About ?
---------------------------------------
*
*

4) What does Circular Linked List Do ?
--------------------------------------
*
*

5) Advantages/Benefits of Circular Linked List :
------------------------------------------------
*
*
*

6) Disadvantages/Drawback of Circular Linked List :
---------------------------------------------------
*
*
*  

7) Examples of Circular Linked List :
-------------------------------------
*
*
_______________________________________________________________________________
      
        *** Stack & Queue *** 
            =============
              1. DSA - Stack
              2. DSA - Expression Parsing
              3. DSA - Queue

      <<<<<<<<< *** Stack & Queue *** >>>>>>>>>
                    =============
__________________________________________________
                                                  |
      Stack & Queue                               |                  
__________________________________________________|
            |
            |
1) What's the Heading ?
-----------------------
* Stack & Queue
                                                                                        
2) Definition of Stack & Queue ?
--------------------------------
*
 
3) What is Stack & Queue About ?
--------------------------------
*
*

4) What does Stack & Queue Do ?
-------------------------------
*
*

5) Advantages/Benefits of Stack & Queue :
-----------------------------------------
*
*
*

6) Disadvantages/Drawback of Stack & Queue :
--------------------------------------------
*
*
*  

7) Examples of Stack & Queue :
------------------------------
*
*
_______________________________________________________________________________

 1. <<<<<<<<< DSA - Stack >>>>>>>>>

    ** Stack Representation :
       ====================
  - The following diagram depicts a stack and its operations −
 
                                                               
                                                              _______________
  -------                                        ----------> | Data Element  | 
  _______\ _____                                /            |_______________| 
 |Data Ele\ment |                              /               
 |_________\____|                             /                  Pop
            \                                /
             V          Last In - First Out /
        |                      |  |                      |
 Push   |    ______________    |  |   ______________     |
        |   | Data Element |   |  |  | Data Element |    |
        |   |______________|   |  |  |______________|    |
        |    ______________    |  |   ______________     |
        |   | Data Element |   |  |  | Data Element |    |
        |   |______________|   |  |  |______________|    |
        |    ______________    |  |   ______________     |
        |   | Data Element |   |  |  | Data Element |    |
        |   |______________|   |  |  |______________|    |
        |    ______________    |  |   ______________     |
        |   | Data Element |   |  |  | Data Element |    |
        |   |______________|   |  |  |______________|    |
        |    ______________    |  |   ______________     |
        |   | Data Element |   |  |  | Data Element |    |
        |   |______________|   |  |  |______________|    |
        |______________________|  |______________________|
                  
                 Stack                Stack

      
         ** Basic Operations :
            ================
  +  Apart from these basic stuffs, a stack is used for the
     two primary operations −
                
      push() − Pushing (storing) an element on the stack.
      ''''''
      pop() − Removing (accessing) an element from the stack.
      '''''
   To use a stack efficiently, we need to check the status of stack as
   well. 
   For the same purpose, the following functionality is added to stacks -
  
   * peek() − get the top data element of the stack, without removing it.
     ''''''
   * isFull() − check if stack is full.
     ''''''''
   * isEmpty() − check if stack is empty.
     '''''''''
    
     - Procedures to support stack functions −
     
      peek()
      '''''''
      Algorithm of peek() function −
      ```````````````````
    _________________________________________
   |  begin procedure peek
   |     return stack[top]
   |  end procedure 
   |_________________________________________
    
    - Implementation of peek() function in C programming language −
      ````````````````````````
          Example -
      _______________________________
     |  int peek() {
     |     return stack[top];
     |  }
     |________________________________
   
     isfull()
     `````````
     Algorithm of isfull() function −
     `````````````````````
   _____________________________________
  |  begin procedure isfull
  |
  |     if top equals to MAXSIZE
  |        return true
  |     else
  |        return false
  |     endif
  |  
  |  end procedure
  |______________________________________
 
    * Implementation of isfull() function in C programming language −
       
      Example -
      ''''''''''
  _____________________________
 |  bool isfull() {
 |     if(top == MAXSIZE)
 |        return true;
 |     else
 |        return false;
 |  }
 |_____________________________
        
     
      isempty()
      ``````````
    Algorithm of isempty() function −
    ``````````````````````
    ____________________________________
   |  begin procedure isempty
   |
   |     if top less than 1
   |        return true
   |     else
   |        return false
   |     endif
   | 
   |  end procedure
   |_____________________________________

   * Implementation of isempty() function in C programming language is
     slightly different.
   * We initialize top at -1, as the index in array starts from 0. 
   * So we check if the top is below zero or -1 to determine if the
     stack is empty.
   * Here's the code −
   
      Example -
      ''''''''''' 
     ________________________________
    |  bool isempty() {
    |     if(top == -1)
    |        return true;
    |     else
    |        return false;
    |  }
    |_________________________________

      Push Operation -
      ''''''''''''''''''
   - The process of putting a new data element onto stack is known as
     a Push Operation.
   - Push operation involves a series of steps −
      
  a) Step 1 − Checks if the stack is full.
     ``````
  b) Step 2 − If the stack is full, produces an error and exit.
     ``````
  c) Step 3 − If the stack is not full, increments top to point next empty space.
     ``````
  d) Step 4 − Adds data element to the stack location, where top is pointing.
     ``````
  e) Step 5 − Returns success.
     ``````
    ___________ 
   |    E      |\
   |___________| \
                  \   Push Operation 
                   \
                    V    
        |                      |           |                      |
        |                      |           |   ______________     |
        |                      |  top----->|  |      E       |    |
        |                      |           |  |______________|    |
        |    ______________    |           |   ______________     |
top---->|   |      D       |   |           |  |      D       |    |
        |   |______________|   |           |  |______________|    |
        |    ______________    |           |   ______________     |
        |   |      C       |   |           |  |      C       |    |
        |   |______________|   |           |  |______________|    |
        |    ______________    |           |   ______________     |
        |   |      B       |   |           |  |      B       |    |
        |   |______________|   |           |  |______________|    |
        |    ______________    |           |   ______________     |
        |   |      A       |   |           |  |      A       |    |
        |   |______________|   |           |  |______________|    |
        |______________________|           |______________________|
                  
                 Stack                Stack
     
    * If the linked list is used to implement the stack, then in step 3, we
      need to allocate space dynamically.
          
       ** Algorithm for PUSH Operation :
          ============================
   + A simple algorithm for Push operation can be derived as follows −
     __________________________________________________
    |  begin procedure push: stack, data
    |
    |     if stack is full
    |        return null
    |     endif
    | 
    |     top ← top + 1
    |     stack[top] ← data
    |
    |  end procedure
    |__________________________________________________

    * Implementation of this algorithm in C, is very easy.
    * the following code −
          
           Example - 
           '''''''''''
    ________________________________________________________________
   |  void push(int data) {
   |     if(!isFull()) {
   |        top = top + 1;   
   |        stack[top] = data;
   |     } else {
   |        printf("Could not insert data, Stack is full.\n");
   |     }
   |  }
   |_________________________________________________________________

         Pop Operation - 
         '''''''''''''''''
   * A Pop operation may involve the following steps −
        
     a) Step 1 − Checks if the stack is empty.
        ''''''
     b) Step 2 − If the stack is empty, produces an error and exit.
        ''''''
     c) Step 3 − If the stack is not empty, accesses the data element 
        ''''''   at which 'top' is pointing.

     d) Step 4 − Decreases the value of top by 1.
        ''''''
     e) Step 5 − Returns success.
        ''''''
     
                                                                   ___________ 
                                                         -------->|    E      |
                                                        /         |___________|  
                     Pop Operation                     /
                                                      |
        |                      |           |          |           |
        |    ______________    |           |                      |
top---->|   |      E       |   |           |                      |
        |   |______________|   |           |                      |
        |    ______________    |           |   ______________     |
        |   |      D       |   |   top---->|  |      D       |    |
        |   |______________|   |           |  |______________|    |
        |    ______________    |           |   ______________     |
        |   |      C       |   |           |  |      C       |    |
        |   |______________|   |           |  |______________|    |
        |    ______________    |           |   ______________     |
        |   |      B       |   |           |  |      B       |    |
        |   |______________|   |           |  |______________|    |
        |    ______________    |           |   ______________     |
        |   |      A       |   |           |  |      A       |    |
        |   |______________|   |           |  |______________|    |
        |______________________|           |______________________|
                  
                 Stack                Stack
    
     ** Algorithm for Pop Operation :
        ===========================
    - A simple algorithm for Pop operation can be derived as follows −
    _________________________________________
   |   begin procedure pop: stack
   | 
   |      if stack is empty
   |         return null
   |      endif
   |
   |      data ← stack[top]
   |      top ← top - 1
   |      return data
   |
   |   end procedure
   |___________________________________________
    
    * Implementation of this algorithm in C, is as follows −
      Example -
    __________________________________________________________________
   |  int pop(int data) {
   |
   |     if(!isempty()) {
   |        data = stack[top];
   |        top = top - 1;   
   |        return data;
   |     } else {
   |        printf("Could not retrieve data, Stack is empty.\n");
   |     }
   |  }
   |____________________________________________________________________
   
     * Complete 'stack program' in C programming language, 
     * We shall see the stack implementation in C programming language here -
  * NOTE - learn the theory aspect of stacks,
           ''''''''''''''''''''''''''''''''''
   _________________________________________________________________________
  |  #include <stdio.h>
  |
  |  int MAXSIZE = 8;       
  |  int stack[8];     
  |  int top = -1;            
  |
  |  int isempty() {
  | 
  |     if(top == -1)
  |        return 1;
  |     else
  |        return 0;
  |  }
  | 
  |  int isfull() {
  |
  |     if(top == MAXSIZE)
  |        return 1;
  |     else
  |        return 0;
  |  }
  |
  |  int peek() {
  |     return stack[top];
  |  }
  |
  |  int pop() {
  |     int data;
  |	
  |     if(!isempty()) {
  |        data = stack[top];
  |        top = top - 1;   
  |        return data;
  |     } else {
  |        printf("Could not retrieve data, Stack is empty.\n");
  |     }
  |  }
  |
  |  int push(int data) {
  |
  |     if(!isfull()) {
  |        top = top + 1;   
  |        stack[top] = data;
  |     } else {
  |        printf("Could not insert data, Stack is full.\n");
  |     }
  |  }
  |
  |  int main() {
  |     // push items on to the stack 
  |     push(3);
  |     push(5);
  |     push(9);
  |     push(1);
  |     push(12);
  |     push(15);
  | 
  |     printf("Element at top of the stack: %d\n" ,peek());
  |     printf("Elements: \n");
  |
  |     // print stack data 
  |     while(!isempty()) {
  |        int data = pop();
  |        printf("%d\n",data);
  |     }
  |
  |     printf("Stack full: %s\n" , isfull()?"true":"false");
  |     printf("Stack empty: %s\n" , isempty()?"true":"false");
  |    
  |     return 0;
  |  }
  |_________________________________________________________________________ 

    * If we compile and run the above program, it will produce the
      result -
        
        Output -
    _______________________________________
   |  Element at top of the stack: 15
   |  Elements:
   |  15
   |  12
   |  1 
   |  9 
   |  5 
   |  3 
   |  Stack full: false
   |  Stack empty: true
   |_________________________________________

   
     * The way to write arithmetic expression is known as a "notation".
     * An arithmetic expression can be written in three different but 
       equivalent notations, i.e., without changing the essence or
       output of an expression :
 
      ** Infix Notation -
         ==============

      ** Prefix Notation -
         ===============
      
      ** Postfix Notation - 
         ================
      
 ____________________________________________________________________________
| Sr.No. |   Infix Notation     |   Prefix Notation    |   Postfix Notation  |
|````````|``````````````````````|``````````````````````|`````````````````````|
|________|______________________|______________________|_____________________|
|  1     |   a + b              |   + a b              |   a b +             | 
|________|______________________|______________________|_____________________|
|  2     |  (a + b) * c         |   * + a b c          |   a b + c *         |
|________|______________________|______________________|_____________________|
|  3     |   a * (b + c)        |   * a + b c          |   a b c + *         | 
|________|______________________|______________________|_____________________|
|  4     |   a / b + c / d      |   + / a b / c d      |   a b / c d / +     |
|________|______________________|______________________|_____________________|        
|  5     |   (a + b) * (c + d)  |   * + a b + c d      |   a b + c d + *     | 
|________|______________________|______________________|_____________________|
|  6     |   ((a + b) * c) - d  |   - * + a b c d      |   a b + c * d -     |
|________|______________________|______________________|_____________________|

    ** Parsings Expressions :
       ====================
     
     * Precedence -
     
     * Associativity -
    
 _____________________________________________________________________________
| Sr.No. |        Operator           |   Precedence     |   Associativity  
|````````|```````````````````````````|``````````````````|`````````````````````
|________|___________________________|__________________|_____________________
|  1     |   Exponentiation ^        |   Highest        |     Right                     
|        |                           |                  | Associative
|________|___________________________|__________________|_____________________
|  2     |   Multiplication ( * ) &  |   Second         |     Left
|        |       Division ( / )      |   Highest        | Associative          
|________|___________________________|__________________|_____________________
|  3     |   Addition ( + ) &        |   Lowest         |     Left             
|        |   Subtraction ( − )       |                  | Associative                    
|________|___________________________|__________________|_____________________

  * The above table shows the default behavior of operators. 
  * At any point of time in expression evaluation, the order can
    be altered by using parenthesis.
        For Example -

    * In a + b*c, the expression part b*c will be evaluated first,
      with multiplication as precedence over addition.
    * We here use parenthesis for a + b to be evaluated first, like (a + b)*c.
                                  '''''                             '''''''''

       ** Postfix Evaluation Algorithm :
          ============================
  - We shall now look at the algorithm on how to 'evaluate postfix notation' −
                             ``````````           `````````````````````````
  __________________________________________________________________________
 | Step 1 − scan the expression from left to right 
 | Step 2 − if it is an operand push it to stack 
 | Step 3 − if it is an operator pull operand from stack and perform operation 
 | Step 4 − store the output of step 3, back to stack 
 | Step 5 − scan the expression until all operands are consumed 
 | Step 6 − pop the stack and perform operation 
 |___________________________________________________________________________

       implementation in C programming language :
       ````````````````````````````````````````
  + Infix notation is easier for humans to read and understand whereas for
__________________________________________________
                                                  |
      DSA - Stack                                 |                  
__________________________________________________|
            |
            |
1) What's the Heading ?
-----------------------
* DSA - Stack
                                                                                        
2) Definition of Stack ?
------------------------
*
 
3) What is Stack About ?
------------------------
*
*

4) What does Stack Do ?
-----------------------
*
*

5) Advantages/Benefits of Stack :
---------------------------------
*
*
*

6) Disadvantages/Drawback of Stack :
------------------------------------
*
*
*  

7) Examples of Stack :
----------------------
*
*
_______________________________________________________________________________

 2. <<<<<<<<< DSA - Expression Parsing >>>>>>>>>

     * The way to write arithmetic expression is known as a "notation".
     * An arithmetic expression can be written in three different but 
       equivalent notations, i.e., without changing the essence or
       output of an expression :
 
      ** Infix Notation -
         ==============

      ** Prefix Notation -
         ===============
      
      ** Postfix Notation - 
         ================
      
 ____________________________________________________________________________
| Sr.No. |   Infix Notation     |   Prefix Notation    |   Postfix Notation  |
|````````|``````````````````````|``````````````````````|`````````````````````|
|________|______________________|______________________|_____________________|
|  1     |   a + b              |   + a b              |   a b +             | 
|________|______________________|______________________|_____________________|
|  2     |  (a + b) * c         |   * + a b c          |   a b + c *         |
|________|______________________|______________________|_____________________|
|  3     |   a * (b + c)        |   * a + b c          |   a b c + *         | 
|________|______________________|______________________|_____________________|
|  4     |   a / b + c / d      |   + / a b / c d      |   a b / c d / +     |
|________|______________________|______________________|_____________________|        
|  5     |   (a + b) * (c + d)  |   * + a b + c d      |   a b + c d + *     | 
|________|______________________|______________________|_____________________|
|  6     |   ((a + b) * c) - d  |   - * + a b c d      |   a b + c * d -     |
|________|______________________|______________________|_____________________|

    ** Parsings Expressions :
       ====================
     
     * Precedence -
     
     * Associativity -
    
 _____________________________________________________________________________
| Sr.No. |        Operator           |   Precedence     |   Associativity  
|````````|```````````````````````````|``````````````````|`````````````````````
|________|___________________________|__________________|_____________________
|  1     |   Exponentiation ^        |   Highest        |     Right                     
|        |                           |                  | Associative
|________|___________________________|__________________|_____________________
|  2     |   Multiplication ( * ) &  |   Second         |     Left
|        |       Division ( / )      |   Highest        | Associative          
|________|___________________________|__________________|_____________________
|  3     |   Addition ( + ) &        |   Lowest         |     Left             
|        |   Subtraction ( − )       |                  | Associative                    
|________|___________________________|__________________|_____________________

  * The above table shows the default behavior of operators. 
  * At any point of time in expression evaluation, the order can
    be altered by using parenthesis.
        For Example -

    * In a + b*c, the expression part b*c will be evaluated first,
      with multiplication as precedence over addition.
    * We here use parenthesis for a + b to be evaluated first, like (a + b)*c.
                                  '''''                             '''''''''

       ** Postfix Evaluation Algorithm :
          ============================
  - We shall now look at the algorithm on how to 'evaluate postfix notation' −
                             ``````````           `````````````````````````
  __________________________________________________________________________
 | Step 1 − scan the expression from left to right 
 | Step 2 − if it is an operand push it to stack 
 | Step 3 − if it is an operator pull operand from stack and perform operation 
 | Step 4 − store the output of step 3, back to stack 
 | Step 5 − scan the expression until all operands are consumed 
 | Step 6 − pop the stack and perform operation 
 |___________________________________________________________________________

       implementation in C programming language :
       ````````````````````````````````````````
  + Infix notation is easier for humans to read and understand whereas 
    for electronic machines like computers, postfix, is the best form 
    of expression to parse. 
  + We shall see here a program to convert and evaluate 
    'infix' notation to 'postfix' notation −
     ``````              ````````
       Example :
   _________________________________________________________________________
  | #include<stdio.h> 
  | #include<string.h> 
  |
  | //char stack
  | char stack[25]; 
  | int top = -1; 
  |
  | void push(char item) {
  |    stack[++top] = item; 
  | } 
  | 
  | char pop() {
  |    return stack[top--]; 
  | } 
  |
  | //returns precedence of operators
  | int precedence(char symbol) {
  |
  |    switch(symbol) {
  |       case '+': 
  |       case '-':
  |          return 2; 
  |          break; 
  |       case '*': 
  |       case '/':
  |          return 3; 
  |          break; 
  |       case '^': 
  |          return 4; 
  |          break; 
  |       case '(': 
  |       case ')': 
  |       case '#':
  |          return 1; 
  |          break; 
  |    } 
  | } 
  |
  | //check whether the symbol is operator?
  | int isOperator(char symbol) {
  |
  |    switch(symbol) {
  |       case '+': 
  |       case '-': 
  |       case '*': 
  |       case '/': 
  |       case '^': 
  |       case '(': 
  |       case ')':
  |          return 1; 
  |       break; 
  |          default:
  |          return 0; 
  |    } 
  | } 
  |
  | //converts infix expression to postfix
  | void convert(char infix[],char postfix[]) {
  |    int i,symbol,j = 0; 
  |    stack[++top] = '#'; 
  |	
  |    for(i = 0;i<strlen(infix);i++) {
  |       symbol = infix[i]; 
  |   		
  |       if(isOperator(symbol) == 0) {
  |          postfix[j] = symbol; 
  |          j++; 
  |       } else {
  |          if(symbol == '(') {
  |             push(symbol); 
  |          } else {
  |             if(symbol == ')') {
  |				
  |                while(stack[top] != '(') {
  |                   postfix[j] = pop(); 
  |                   j++; 
  |                } 
  |					
  |                pop();   //pop out (. 
  |             } else {
  |                if(precedence(symbol)>precedence(stack[top])) {
  |                   push(symbol); 
  |                } else {
  |					
  |                   while(precedence(symbol)<=precedence(stack[top])) {
  |                      postfix[j] = pop(); 
  |                      j++; 
  |                   } 
  |   						
  |                   push(symbol); 
  |                }
  |             }
  |          }
  |       }
  |    }
  |	
  |    while(stack[top] != '#') {
  |       postfix[j] = pop(); 
  |       j++; 
  |    } 
  |	
  |    postfix[j]='\0';  //null terminate string. 
  | } 
  |
  | //int stack
  | int stack_int[25]; 
  | int top_int = -1; 
  |
  | void push_int(int item) {
  |    stack_int[++top_int] = item; 
  | } 
  |
  | char pop_int() {
  |    return stack_int[top_int--]; 
  | } 
  |
  | //evaluates postfix expression
  | int evaluate(char *postfix){
  | 
  |    char ch;
  |    int i = 0,operand1,operand2;
  |
  |    while( (ch = postfix[i++]) != '\0') {
  |	
  |       if(isdigit(ch)) {
  |      	 push_int(ch-'0');  // Push the operand 
  |       } else {
  |          //Operator,pop two  operands 
  |          operand2 = pop_int();
  |          operand1 = pop_int();
  |			
  |          switch(ch) {
  |             case '+':
  |                push_int(operand1+operand2);
  |                break;
  |             case '-':
  |                push_int(operand1-operand2);
  |                break;
  |             case '*':
  |                push_int(operand1*operand2);
  |                break;
  |             case '/':
  |                push_int(operand1/operand2);
  |                break;
  |          }
  |       }
  |    }
  |	
  |    return stack_int[top_int];
  | }
  |
  | void main() { 
  |    char infix[25] = "1*(2+3)",postfix[25]; 
  |    convert(infix,postfix); 
  |	
  |    printf("Infix expression is: %s\n" , infix);
  |    printf("Postfix expression is: %s\n" , postfix);
  |    printf("Evaluated expression is: %d\n" , evaluate(postfix));
  | }
  |___________________________________________________________________________  
     
     * If we compile and run the above program, it will produce the
       result - 
                 Output :
    _____________________________________
   |  Infix expression is: 1*(2+3)
   |  Postfix expression is: 123+*
   |  Result is: 5
   |_____________________________________
__________________________________________________
                                                  |
      DSA - Expression Parsing                    |                  
__________________________________________________|
            |
            |
1) What's the Heading ?
-----------------------
* DSA - Expression Parsing
                                                                                        
2) Definition of Expression Parsing ?
-------------------------------------
*
 
3) What is Expression Parsing About ?
-------------------------------------
*
*

4) What does Expression Parsing Do ?
------------------------------------
*
*

5) Advantages/Benefits of Expression Parsing :
----------------------------------------------
*
*
*

6) Disadvantages/Drawback of Expression Parsing :
-------------------------------------------------
*
*
*  

7) Examples of Expression Parsing :
-----------------------------------
*
*
_______________________________________________________________________________

 3. <<<<<<<<< DSA - Queue >>>>>>>>>
      
    * 'Queue' is an abstract data structure, somewhat similar to Stacks.
    * Unlike stacks, a 'queue' is open at both its ends.
      + One end is always used to insert data (enqueue),
      + and the other is used to remove data (dequeue).
    * Queue follows First-In-First-Out methodology, i.e., 
      data item stored first will be accessed first.

 * A real-world example of queue can be a single-lane one-way road,
   where the vehicle enters first, exits first.
 * More real-world examples can be seen as queues at the ticket windows
   and bus stops. 
      
      ** Queue Representation :
         ====================
  + in queue, we access both ends for different reasons.
  + diagram below tries to explain 'queue representation' as 'data structure' −
        ______     ______     ______     ______     ______     ______
 ___   /      \   /      \   /      \   /      \   /      \   /      \   ____
|In >>|  Data  | |  Data  | |  Data  | |  Data  | |  Data  | |  Data  | |Out >>   ```   \______/   \______/   \______/   \______/   \______/   \______/   ````
       
       Last In Last Out                                     First In First Out
                                QUEUE 

   * As in stacks, a queue can also be implemented using Arrays,
     Linked-lists, Pointers and Structures. 
   * For the sake of simplicity, we shall implement queues using 
     one-dimensional array.
   
       ** Basic Operations :
          '''''''''''''''''''
      the basic operations associated with queues −
   
     * enqueue() − add (store) an item to the queue.
       '''''''''
     * dequeue() − remove (access) an item from the queue.
       '''''''''
   + Few more functions are required to make the above-mentioned
     queue operation efficient -
       
   * peek() − Gets the element at the front of the queue without removing it.
     ''''''
   * isfull() − Checks if the queue is full.
     ''''''''
   * isempty() − Checks if the queue is empty.
     '''''''''
      
     + In 'queue', we always 'dequeue' (or access) data, pointed by "front"
       pointer and while 'enqueing' (or storing) data in the 'queue' we take
       help of "rear" pointer.  
     
   * Let's first learn about supportive functions of a queue −
    
      * peek() *
        ''''''
       + This function helps to see the data at the front of the queue.
       + The algorithm of peek() function is as follows −
             ''''''''''''''''''''''''''''
                Algorithm
                ``````````
       ________________________________
      |  begin procedure peek
      |     return queue[front]
      |  end procedure
      |________________________________
   
    Implementation of peek() function in C programming language − 
    `````````````````````````````````
    _________________________________    
   |  int peek() {
   |     return queue[front];
   |  }
   |_________________________________

       * isfull() *
         ''''''''
        Algorithm
    ______________________________________
   |  begin procedure isfull
   |
   |     if rear equals to MAXSIZE
   |        return true
   |     else
   |        return false
   |     endif
   | 
   |  end procedure
   |__________________________________________
  
     + Implementation of isfull() function in C programming language −
       ''''''''''''''''''''''''''
           Example -
   _________________________________________
  |  bool isfull() {
  |     if(rear == MAXSIZE - 1)
  |        return true;
  |     else
  |        return false;
  |  }
  |___________________________________________
  
     * isempty() 
       '''''''''
       Algorithm of isempty() function −

       Algorithm
   ________________________________________________________________
  |  begin procedure isempty
  |
  |     if front is less than MIN  OR front is greater than rear
  |         return true
  |     else
  |         return false
  |     endif
  |  
  |  end procedure
  |____________________________________________________________
  
  + If the value of "front" is less than "MIN" or 0, it tells that the queue is
    not yet initialized, hence empty.
  
    + Implementation of isempty() function the C programming code −
            
          Example -
    _________________________________________
   |  bool isempty() {
   |     if(front < 0 || front > rear) 
   |        return true;
   |     else
   |        return false;
   |  }
   |__________________________________________
 
      ** Enqueue Operation :
         =================
   + Queues maintain two data pointers, front and rear.
   + Therefore, its operations are comparatively difficult to implement than  
     that of stacks.
   
     The following steps should be taken to enqueue (insert) data into a
     queue -
       
    * Step 1 − Check if the queue is full.
      ''''''
    * Step 2 − If the queue is full, produce overflow error and exit.
      ''''''
    * Step 3 − If the queue is not full, increment "rear" pointer to point
      ''''''   the next empty space.

    * Step 4 − Add data element to the queue location, where the rear is
      ''''''   pointing.  

    * Step 5 − return success.
      ''''''
         'Algorithm for enqueue operation'
          '''''''''''''''''''''''''''''''
    __________________________________________
   |  procedure enqueue(data)      
   |
   |     if queue is full
   |        return overflow
   |     endif
   |
   |     rear ← rear + 1
   |     queue[rear] ← data
   |     return true
   |
   |  end procedure
   |__________________________________________
     
    Implementation of enqueue() in C programming language −
    ```````````````````````````
     Example -
    ________________________________________________
   |  int enqueue(int data)      
   |     if(isfull())
   |        return 0;
   | 
   |     rear = rear + 1;
   |     queue[rear] = data;
   |
   |     return 1;
   |  end procedure
   |_________________________________________________
       
      ** Dequeue Operation : 
         =================
    steps are taken to perform dequeue operation −
      
   * Step 1 − Check if the queue is empty.
     ``````
   * Step 2 − If the queue is empty, produce underflow error and exit.
     ``````
   * Step 3 − If the queue is not empty, access the data where front 
     ``````   is pointing.

   * Step 4 − Increment front pointer to point to the next available 
     ```````  data element.

   * Step 5 − Return success.
     ```````
       + Algorithm for dequeue operation -
     _____________________________________________
    |  procedure dequeue
    |
    |     if queue is empty
    |        return underflow
    |     end if
    |
    |     data = queue[front]
    |     front ← front + 1
    |     return true
    |
    |  end procedure
    |______________________________________________
          
     Implementation of dequeue() in C programming language −
     ```````````````````````````
        Example -  
    __________________________________________
   |  int dequeue() {
   |     if(isempty())
   |        return 0;
   |
   |     int data = queue[front];
   |     front = front + 1;
   |
   |     return data;
   |  }
   |__________________________________________
 
     * complete Queue program in C programming language :
         
         Implementation in C -
   _________________________________________________________________________
  |  #include <stdio.h>
  |  #include <string.h>
  |  #include <stdlib.h>
  |  #include <stdbool.h>
  |
  |  #define MAX 6
  |
  |  int intArray[MAX];
  |  int front = 0;
  |  int rear = -1;
  |  int itemCount = 0;
  |
  |  int peek() {
  |     return intArray[front];
  |  }
  |
  |  bool isEmpty() {
  |     return itemCount == 0;
  |  }
  |
  |  bool isFull() {
  |     return itemCount == MAX;
  |  }
  | 
  |  int size() {
  |     return itemCount;
  |  }  
  |
  |  void insert(int data) {
  |
  |     if(!isFull()) {
  |	
  |        if(rear == MAX-1) {
  |           rear = -1;            
  |        }       
  |  
  |        intArray[++rear] = data;
  |        itemCount++;
  |     }
  |  }
  |
  |  int removeData() {
  |     int data = intArray[front++];
  |	
  |     if(front == MAX) {
  |        front = 0;
  |     }
  |	
  |     itemCount--;
  |     return data;  
  |  }
  |
  |  int main() {
  |     /* insert 5 items */
  |     insert(3);
  |     insert(5);
  |     insert(9);
  |     insert(1);
  |     insert(12);
  |
  |     // front : 0
  |     // rear  : 4
  |     // ------------------
  |     // index : 0 1 2 3 4 
  |     // ------------------
  |     // queue : 3 5 9 1 12
  |     insert(15);
  |
  |     // front : 0
  |     // rear  : 5
  |     // ---------------------
  |     // index : 0 1 2 3 4  5 
  |     // ---------------------
  |     // queue : 3 5 9 1 12 15
  |	
  |     if(isFull()) {
  |        printf("Queue is full!\n");   
  |     }
  |
  |     // remove one item 
  |     int num = removeData();
  |	
  |     printf("Element removed: %d\n",num);
  |     // front : 1
  |     // rear  : 5
  |     // -------------------
  |     // index : 1 2 3 4  5
  |     // -------------------
  |     // queue : 5 9 1 12 15
  |
  |     // insert more items
  |     insert(16);
  |
  |     // front : 1
  |     // rear  : -1
  |     // ----------------------
  |     // index : 0  1 2 3 4  5
  |     // ----------------------
  |     // queue : 16 5 9 1 12 15
  |
  |     // As queue is full, elements will not be inserted. 
  |     insert(17);
  |     insert(18);
  |
  |     // ----------------------
  |     // index : 0  1 2 3 4  5
  |     // ----------------------
  |     // queue : 16 5 9 1 12 15
  |     printf("Element at front: %d\n",peek());
  |
  |     printf("----------------------\n");
  |     printf("index : 5 4 3 2  1  0\n");
  |     printf("----------------------\n");
  |     printf("Queue:  ");
  |	
  |     while(!isEmpty()) {
  |        int n = removeData();           
  |        printf("%d ",n);
  |     }   
  |  }
  |________________________________________________________________________
     
    * If we compile and run the above program, it will produce the
      result -
                Output -
    ____________________________________
   |  Queue is full!
   |  Element removed: 3
   |  Element at front: 5
   |  ----------------------
   |  index : 5 4 3 2 1 0
   |  ----------------------
   |  Queue: 5 9 1 12 15 16 
   |_____________________________________
__________________________________________________
                                                  |
     DSA - Queue                                  |                  
__________________________________________________|
            |
            |
1) What's the Heading ?
-----------------------
* DSA - Queue
                                                                                        
2) Definition of Queue ?
------------------------
*
 
3) What is Queue About ?
------------------------
* 
*

4) What does Queue Do ?
-----------------------
*
*

5) Advantages/Benefits of Queue :
---------------------------------
*
*
*

6) Disadvantages/Drawback of Queue :
------------------------------------
*
*
*  

7) Examples of Queue :
----------------------
*
*
_______________________________________________________________________________
         
       *** Searching Techniques ***
           ====================
              1. DSA - Linear Search
              2. DSA - Binary Search
              3. DSA - Interpolation Search
              4. DSA - Hash Table

       <<<<<<<<< *** Searching Techniques *** >>>>>>>>>
                     ====================
__________________________________________________
                                                  |
            Searching Techniques                  |                  
__________________________________________________|
            |
            |
1) What's the Heading ?
-----------------------
* Searching Techniques
                                                                                        
2) Definition of Searching Techniques ?
---------------------------------------
*
 
3) What is Searching Techniques About ?
---------------------------------------
*
*

4) What does Searching Techniques Do ?
--------------------------------------
*
*

5) Advantages/Benefits of Searching Techniques :
------------------------------------------------
*
*
*

6) Disadvantages/Drawback of Searching Techniques :
---------------------------------------------------
*
*
*  

7) Examples of Searching Techniques :
-------------------------------------
*
*
_______________________________________________________________________________

 1. <<<<<<<<< DSA - Linear Search >>>>>>>>>
     
   * Linear search is a very simple search algorithm.
   * this type of search, a sequential search is made over all items
     one by one .
   * Every item is checked and if a match is found then that particular
     item is returned, otherwise the search continues till the end of    
     the data collection. 
          
           Linear Search -
           ''''''''''''''''
       
       |
       |
       V
      ____   ____   ____   ____   ____   ____   ____   ____   ____   ____
     ||10|| | 14 | | 19 | | 26 | | 27 | | 31 | | 33 | | 35 | | 42 | | 44 |
     |||||| |____| |____| |____| |____| |____| |____| |____| |____| |____|
       =      
       33
       
              |
              |
              V
      ____   ____   ____   ____   ____   ____   ____   ____   ____   ____
     | 10 | ||14|| | 19 | | 26 | | 27 | | 31 | | 33 | | 35 | | 42 | | 44 |
     |____| |||||| |____| |____| |____| |____| |____| |____| |____| |____|
              =      
              33

                     |
                     |
                     V
      ____   ____   ____   ____   ____   ____   ____   ____   ____   ____
     | 10 | | 14 | ||19|| | 26 | | 27 | | 31 | | 33 | | 35 | | 42 | | 44 |
     |____| |____| |||||| |____| |____| |____| |____| |____| |____| |____|
                     =      
                     33

                            |
                            |
                            V
      ____   ____   ____   ____   ____   ____   ____   ____   ____   ____
     | 10 | | 14 | | 19 | ||26|| | 27 | | 31 | | 33 | | 35 | | 42 | | 44 |
     |____| |____| |____| |||||| |____| |____| |____| |____| |____| |____|
                            =      
                            33

                                   |
                                   |
                                   V
      ____   ____   ____   ____   ____   ____   ____   ____   ____   ____
     | 10 | | 14 | | 19 | | 26 | ||27|| | 31 | | 33 | | 35 | | 42 | | 44 |
     |____| |____| |____| |____| |||||| |____| |____| |____| |____| |____|
                                   =      
                                   33
   
                                          |
                                          |
                                          V
      ____   ____   ____   ____   ____   ____   ____   ____   ____   ____
     | 10 | | 14 | | 19 | | 26 | | 27 | ||31|| | 33 | | 35 | | 42 | | 44 |
     |____| |____| |____| |____| |____| |||||| |____| |____| |____| |____|
                                          =      
                                          33

                                                 |
                                                 |
                                                 V
      ____   ____   ____   ____   ____   ____   ____   ____   ____   ____
     | 10 | | 14 | | 19 | | 26 | | 27 | | 31 | ||33|| | 35 | | 42 | | 44 |
     |____| |____| |____| |____| |____| |____| |||||| |____| |____| |____|
                                                 =      
                                                 33
      
        + Algorithm : 
          ```````````
    _________________________________________________________________
   |  Step 1: Set i to 1
   |  Step 2: if i > n then go to step 7
   |  Step 3: if A[i] = x then go to step 6
   |  Step 4: Set i to i + 1
   |  Step 5: Go to Step 2
   |  Step 6: Print Element x Found at index i and go to step 8
   |  Step 7: Print element not found
   |  Step 8: Exit
   |__________________________________________________________________
       
         + Pseudocode :
           `````````````
    ___________________________________________________
   |  procedure linear_search (list, value)
   |
   |     for each item in the list
   |        if match item == value
   |           return the item's location
   |        end if
   |     end for
   |
   |  end procedure 
   |_____________________________________________________
       
     * linear search implementation in C programming language,
    
         * Linear Search Program :
           ''''''''''''''''''''''''
    ________________________________________________________________________
   |  #include <stdio.h>
   |
   |  #define MAX 20
   |
   |  // array of items on which linear search will be conducted.
   |  int intArray[MAX] = {1,2,3,4,6,7,9,11,12,14,15,16,17,19,33,34,43,45,55,66};
   |
   |  void printline(int count) {
   |     int i;
   |	
   |     for(i = 0;i <count-1;i++) {
   |        printf("=");
   |     }
   |	
   |     printf("=\n");
   |  }
   |
   |  // this method makes a linear search. 
   |  int find(int data) {
   |
   |     int comparisons = 0;
   |     int index = -1;
   |     int i;
   |
   |     // navigate through all items 
   |     for(i = 0;i<MAX;i++) {
   |	
   |        // count the comparisons made 
   |        comparisons++;
   |		
   |        // if data found, break the loop
   |        if(data == intArray[i]) {
   |           index = i;
   |           break;
   |        }
   |     }   
   |	
   |     printf("Total comparisons made: %d", comparisons);
   |     return index;
   |  }
   |
   |  void display() {
   |     int i;
   |     printf("[");
   |	
   |     // navigate through all items 
   |     for(i = 0;i<MAX;i++) {
   |        printf("%d ",intArray[i]);
   |     }
   |	
   |     printf("]\n");
   |  }
   |
   |  void main() {
   |     printf("Input Array: ");
   |     display();
   |     printline(50);
   |	 
   |     //find location of 1
   |     int location = find(55);
   |
   |     // if element was found 
   |     if(location != -1)
   |        printf("\nElement found at location: %d" ,(location+1));
   |     else
   |        printf("Element not found.");
   |  }
   |__________________________________________________________________________
    
      * If we compile and run the above program, it will produce the
        result -
                  Output -
   __________________________________________________________________________
  |
  |  Input Array: [1 2 3 4 6 7 9 11 12 14 15 16 17 19 33 34 43 45 55 66 ]
  |  ==================================================
  |  Total comparisons made: 19
  |  Element found at location: 19
  |__________________________________________________________________________
__________________________________________________
                                                  |
         DSA - Linear Search                      |                  
__________________________________________________|
            |
            |
1) What's the Heading ?
-----------------------
* DSA - Linear Search
                                                                                        
2) Definition of Linear Search ?
--------------------------------
*
 
3) What is Linear Search About ?
--------------------------------
*
*

4) What does Linear Search Do ?
-------------------------------
*
*

5) Advantages/Benefits of Linear Search :
-----------------------------------------
*
*
*

6) Disadvantages/Drawback of Linear Search :
--------------------------------------------
*
*
*  

7) Examples of Linear Search :
------------------------------
*
*
_______________________________________________________________________________

 2. <<<<<<<<< DSA - Binary Search >>>>>>>>>
 
     * 'Binary search' is a fast search algorithm with run-time complexity of
       Ο(log n).            `````````````````````      ```````````````````
     * This search algorithm works on the principle of divide and conquer.
     * For this algorithm to work properly, the data collection should be
       in the sorted form.
      
         ** How Binary Search Works ?
            =======================
   * For a 'binary search' to work, it is mandatory for the 'target array' to
     be 'sorted'.
   * The following is our 'sorted array' and let us assume that we need to 
     search the location of value 31 using 'binary search'.
     ```````````````````````````````
    _______________________________________________________________________
   |  ____   ____   ____   ____   ____   ____   ____   ____   ____   ____  |
   | | 10 | | 14 | | 19 | | 26 | | 27 | |*31*| | 33 | | 35 | | 42 | | 44 | |
   | |____| |____| |____| |____| |____| |****| |____| |____| |____| |____| | 
   |_______________________________________________________________________|             0      1      2      3      4      5      6      7      8      9                              
  * First, we shall determine half of the array by using this formula −                 _____________________________________
     |  mid = low + (high - low) / 2       |
     |_____________________________________|    
  
  * Here it is, 0 + (9 - 0 ) / 2 = 4 (integer value of 4.5). 
                ```````````````````````````````````````````
  * So, 4 is the mid of the array.
                                    
                                   |
                                   |
                                   V
    _______________________________________________________________________
   |  ____   ____   ____   ____   ____   ____   ____   ____   ____   ____  |
   | | 10 | | 14 | | 19 | | 26 | ||27|| |*31*| | 33 | | 35 | | 42 | | 44 | |
   | |____| |____| |____| |____| |||||| |****| |____| |____| |____| |____| | 
   |_______________________________________________________________________|             0      1      2      3      4      5      6      7      8      9
   
     * Now we compare the value stored at location 4, with the value
       being searched, i.e. 31. 
     * We find that the value at location 4 is 27, which is not match.
     * As the value is greater than 27 and we have a sorted array, 
       so we also know that the target value must be in the
       upper portion of the array.
    _______________________________________________________________________
   |  ____   ____   ____   ____   ____   ____   ____   ____   ____   ____  |
   | |    | |    | |    | |    | |    | |*31*| | 33 | | 35 | | 42 | | 44 | |
   | |____| |____| |____| |____| |____| |****| |____| |____| |____| |____| | 
   |_______________________________________________________________________|             0      1      2      3      4      5      6      7      8      9
   
    * We change our low to mid + 1 and find the new mid value again.
    ________________________________________
   |  low = mid + 1
   |  mid = low + (high - low) / 2
   |________________________________________           
                                                        
                                                        |
                                                        |
                                                        V
    _______________________________________________________________________
   |  ____   ____   ____   ____   ____   ____   ____   ____   ____   ____  |
   | |    | |    | |    | |    | |    | |*31*| | 33 | ||35|| | 42 | | 44 | |
   | |____| |____| |____| |____| |____| |****| |____| |||||| |____| |____| | 
   |_______________________________________________________________________|             0      1      2      3      4      5      6      7      8      9
    
   * The value stored at location 7 is not a match, rather it is more than
     what we are looking for.
   * So, the value must be in the lower part from this location.

    _______________________________________________________________________
   |  ____   ____   ____   ____   ____   ____   ____   ____   ____   ____  |
   | |    | |    | |    | |    | |    | |*31*| | 33 | |    | |    | |    | |
   | |____| |____| |____| |____| |____| |****| |____| |____| |____| |____| | 
   |_______________________________________________________________________|             0      1      2      3      4      5      6      7      8      9
    
   * Hence, we calculate the mid again. This time it is 5.


                                          |
                                          |
                                          V
    _______________________________________________________________________
   |  ____   ____   ____   ____   ____   ____   ____   ____   ____   ____  |
   | |    | |    | |    | |    | |    | |*31*| | 33 | |    | |    | |    | |
   | |____| |____| |____| |____| |____| |****| |____| |____| |____| |____| | 
   |_______________________________________________________________________|             0      1      2      3      4      5      6      7      8      9
 
   * We compare the value stored at location 5 with our target value.
   * We find that it is a match.

    _______________________________________________________________________
   |  ____   ____   ____   ____   ____   ____   ____   ____   ____   ____  |
   | |    | |    | |    | |    | |    | |*31*| |    | |    | |    | |    | |
   | |____| |____| |____| |____| |____| |****| |____| |____| |____| |____| | 
   |_______________________________________________________________________|             0      1      2      3      4      5      6      7      8      9
 
   * We conclude that the target value 31 is stored at location 5.
   
   * Binary search halves the searchable items and thus reduces the
     count of comparisons to be made to very less numbers.
          
       * Pseudocode -
         '''''''''''''
    The pseudocode of binary search algorithms should look like this −
        ``````````````````````````````````````
    ________________________________________________________________________
   |
   |  Procedure binary_search
   |     A ← sorted array
   |     n ← size of array
   |     x ← value to be searched
   |
   |     Set lowerBound = 1
   |     Set upperBound = n 
   |
   |     while x not found
   |        if upperBound < lowerBound 
   |           EXIT: x does not exists.
   |    
   |        set midPoint = lowerBound + ( upperBound - lowerBound ) / 2
   |   
   |        if A[midPoint] < x
   |           set lowerBound = midPoint + 1
   |          
   |        if A[midPoint] > x
   |           set upperBound = midPoint - 1 
   |
   |        if A[midPoint] = x 
   |           EXIT: x found at location midPoint
   |     end while
   |
   |  end procedure
   |_______________________________________________________________________ 
    
    * about binary search implementation using array in C
      programming language - 
    
      + Binary search is a fast search algorithm with run-time 
        complexity of Ο(log n).
      + This search algorithm works on the principle of divide and conquer.
      + For this algorithm to work properly, the data collection
        should be in a sorted form.
   
         Implementation in C -
         ``````````````````````
  ___________________________________________________________________________
 |  #include <stdio.h>
 |
 |  #define MAX 20
 |
 |  // array of items on which linear search will be conducted. 
 |  int intArray[MAX] = {1,2,3,4,6,7,9,11,12,14,15,16,17,19,33,34,43,45,55,66};
 |
 |  void printline(int count) {
 |     int i;
 |  	
 |     for(i = 0;i <count-1;i++) {
 |        printf("=");
 |     }
 |	
 |     printf("=\n");
 |  }
 |
 |  int find(int data) {
 |     int lowerBound = 0;
 |     int upperBound = MAX -1;
 |     int midPoint = -1;
 |     int comparisons = 0;      
 |     int index = -1;
 |	
 |     while(lowerBound <= upperBound) {
 |        printf("Comparison %d\n" , (comparisons +1) );
 |        printf("lowerBound : %d, intArray[%d] = %d\n",lowerBound,lowerBound,
 |           intArray[lowerBound]);
 |        printf("upperBound : %d, intArray[%d] = %d\n",upperBound,upperBound,
 |           intArray[upperBound]);
 |        comparisons++;
 | 		
 |        // compute the mid point
 |        // midPoint = (lowerBound + upperBound) / 2;
 |        midPoint = lowerBound + (upperBound - lowerBound) / 2;	
 |		
 |        // data found
 |        if(intArray[midPoint] == data) {
 |           index = midPoint;
 |           break;
 |        } else {
 |           // if data is larger 
 |           if(intArray[midPoint] < data) {
 |              // data is in upper half
 |              lowerBound = midPoint + 1;
 |           }
 |          // data is smaller 
 |          else {
 |             // data is in lower half 
 |             upperBound = midPoint -1;
 |          }
 |       }               
 |     }
 |     printf("Total comparisons made: %d" , comparisons);
 |     return index;
 |  }
 | 
 |  void display() {
 |    int i;
 |    printf("[");
 |	
 |    // navigate through all items 
 |    for(i = 0;i<MAX;i++) {
 |       printf("%d ",intArray[i]);
 |    }
 |	
 |    printf("]\n");
 |  }
 |
 |  void main() {
 |     printf("Input Array: ");
 |     display();
 |     printline(50);
 |	
 |     //find location of 1
 |     int location = find(55);
 |
 |     // if element was found 
 |     if(location != -1)
 |        printf("\nElement found at location: %d" ,(location+1));
 |     else
 |        printf("\nElement not found.");
 |  }
 |___________________________________________________________________________ 

   * If we compile and run the above program then it would produce
     the result -
                   Output -
    _________________________________________________________________________
   |
   |  Input Array: [1 2 3 4 6 7 9 11 12 14 15 16 17 19 33 34 43 45 55 66 ]
   |  ==================================================
   |  Comparison 1
   |  lowerBound : 0, intArray[0] = 1
   |  upperBound : 19, intArray[19] = 66
   |  Comparison 2
   |  lowerBound : 10, intArray[10] = 15
   |  upperBound : 19, intArray[19] = 66
   |  Comparison 3
   |  lowerBound : 15, intArray[15] = 34
   |  upperBound : 19, intArray[19] = 66
   |  Comparison 4
   |  lowerBound : 18, intArray[18] = 55
   |  upperBound : 19, intArray[19] = 66
   |  Total comparisons made: 4
   |  Element found at location: 19
   |__________________________________________________________________________


__________________________________________________
                                                  |
        DSA - Binary Search                       |                  
__________________________________________________|
            |
            |
1) What's the Heading ?
-----------------------
* DSA - Binary Search
                                                                                        
2) Definition of Binary Search ?
--------------------------------
*
 
3) What is Binary Search About ?
--------------------------------
*
*

4) What does Binary Search Do ?
-------------------------------
*
*

5) Advantages/Benefits of Binary Search :
-----------------------------------------
*
*
*

6) Disadvantages/Drawback of Binary Search :
--------------------------------------------
*
*
*  

7) Examples of Binary Search :
------------------------------
*
*
_______________________________________________________________________________

 3. <<<<<<<<< DSA - Interpolation Search >>>>>>>>>
     
    * Interpolation search is an improved variant of binary search. 
    * This search algorithm works on the probing position of the 
      required value.
    * For this algorithm to work properly, the data collection should be
      in a sorted form and equally distributed. 
    
    * 'Binary search' has a huge advantage of time complexity over 'linear
      search'.
    * 'Linear search' has worst-case complexity of Ο(n) whereas binary search
      has Ο(log n).
    
       ** Positioning in Binary Search -
          ============================
    * In binary search, if the desired data is not found then the rest of the
      list is divided in two parts, lower and higher.
    * The search is carried out in either of them.
      
      ____   ____   ____   ____   ____   ____   ____   ____   ____   ____
     | 1  | ||2||| | 3  | | 4  | | 5  | | 6  | | 7  | | 8  | | 9  | | 10 |
     |____| |||||| |____| |____| |____| |____| |____| |____| |____| |____|
      (_______________________________) (_______________________________) 
      ____   ____   ____   ____   ____   ____   ____   ____   ____   ____
     | 1  | ||2||| | 3  | | 4  | | 5  | |    | |    | |    | |    | |    |
     |____| |||||| |____| |____| |____| |____| |____| |____| |____| |____|
      (______________) (_____________)
      ____   ____   ____   ____   ____   ____   ____   ____   ____   ____
     | 1  | ||2||| |    | |    | |    | |    | |    | |    | |    | |    |
     |____| |||||| |____| |____| |____| |____| |____| |____| |____| |____|
      (__)   (__)
      ____   ____   ____   ____   ____   ____   ____   ____   ____   ____
     |    | ||2||| |    | |    | |    | |    | |    | |    | |    | |    |
     |____| |||||| |____| |____| |____| |____| |____| |____| |____| |____|
               ^
               | 
               |
  
   * Even when the data is sorted, binary search does not take advantage 
     to probe the position of the desired data.
   
   ** Position Probing in Interpolation Search :
      ======================================== 
     
    * Interpolation search finds a particular item by computing the probe
      position.
    * Initially, the probe position is the position of the middle
      most item of the collection.
      ____   ____   ____   ____   ____   ____   ____   ____   ____   ____
     | 1  | ||2||| | 3  | | 4  | | 5  | | 6  | | 7  | | 8  | | 9  | | 10 |
     |____| |||||| |____| |____| |____| |____| |____| |____| |____| |____|
      (________)(_______________________________________________________) 
      ____   ____   ____   ____   ____   ____   ____   ____   ____   ____
     |    | ||2||| |    | |    | |    | |    | |    | |    | |    | |    |
     |____| |||||| |____| |____| |____| |____| |____| |____| |____| |____|
              ^
              |
              |
    * If a match occurs, then the index of the item is returned.
    * To split the list into two parts, we use following method -
     ______________________________________________________________
    |
    |  mid = Lo + ((Hi - Lo) / (A[Hi] - A[Lo])) * (X - A[Lo])
    |
    |  where −
    |     A    = list
    |     Lo   = Lowest index of the list
    |     Hi   = Highest index of the list
    |     A[n] = Value stored at index n in the list
    |______________________________________________________________
   
   * If the middle item is greater than the item, then the probe position is 
     again calculated in the sub-array to the right of the middle item.
   * Otherwise, the item is searched in the subarray to the left of the
     middle item.
   * This process continues on the sub-array as well until
     the size of subarray reduces to zero.  
   
   * Runtime complexity of interpolation search algorithm is Ο(log (log n))
     as compared to Ο(log n) of BST in favorable situations. ``````````````
                    ````````
     * Algorithm -
       `````````
       As it is an improvisation of the existing BST algorithm, we are
       mentioning the steps to search the 'target' data value index, 
       using position probing −
    ___________________________________________________________________________
   |
   |  Step 1 − Start searching data from middle of the list.
   |  Step 2 − If it is a match, return the index of the item, and exit.
   |  Step 3 − If it is not a match, probe position.
   |  Step 4 − Divide the list using probing formula and find the new midle.
   |  Step 5 − If data is greater than middle, search in higher sub-list.
   |  Step 6 − If data is smaller than middle, search in lower sub-list.
   |  Step 7 − Repeat until match.
   |___________________________________________________________________________

       Pseudocode -
   ____________________________________________________________________________
  |  A → Array list
  |  N → Size of A
  |  X → Target Value
  |
  |  Procedure Interpolation_Search()
  |
  |     Set Lo  →  0
  |     Set Mid → -1
  |     Set Hi  →  N-1
  |
  |     While X does not match
  |  
  |        if Lo equals to Hi OR A[Lo] equals to A[Hi]
  |           EXIT: Failure, Target not found
  |        end if
  |    
  |        Set Mid = Lo + ((Hi - Lo) / (A[Hi] - A[Lo])) * (X - A[Lo]) 
  |
  |        if A[Mid] = X
  |           EXIT: Success, Target found at Mid
  |        else 
  |           if A[Mid] < X
  |              Set Lo to Mid+1
  |           else if A[Mid] > X
  |              Set Hi to Mid-1
  |           end if
  |        end if
  |     End While
  |
  |  End Procedure
  |_________________________________________________________________________
    
     * implementation of interpolation search in C programming language -
     * Interpolation Search Program in C -
        
          + It's runtime complexity is log2(log2 n).
                                       ````````````
       ** Implementation in C -
   _____________________________________________________________________________________________
  |  #include<stdio.h>
  |
  |  #define MAX 10
  |
  |  // array of items on which linear search will be conducted. 
  |  int list[MAX] = { 10, 14, 19, 26, 27, 31, 33, 35, 42, 44 };
  |   
  |  int find(int data) {
  |     int lo = 0;
  |     int hi = MAX - 1;
  |     int mid = -1;
  |     int comparisons = 1;      
  |     int index = -1;
  |
  |     while(lo <= hi) {
  |        printf("\nComparison %d  \n" , comparisons ) ;
  |        printf("lo : %d, list[%d] = %d\n", lo, lo, list[lo]);
  |        printf("hi : %d, list[%d] = %d\n", hi, hi, list[hi]);
  |    
  |        comparisons++;
  |
  |        // probe the mid point 
  |        mid = lo + (((double)(hi - lo) / (list[hi] - list[lo])) * (data - list[lo]));
  |        printf("mid = %d\n",mid);
  |
  |        // data found 
  |        if(list[mid] == data) {
  |           index = mid;
  |           break;
  |        } else {
  |           if(list[mid] < data) {
  |              // if data is larger, data is in upper half 
  |              lo = mid + 1;
  |           } else {
  |              // if data is smaller, data is in lower half 
  |              hi = mid - 1;
  |           }
  |        }               
  |     }
  | 
  |     printf("\nTotal comparisons made: %d", --comparisons);
  |     return index;
  |  }
  |
  |  int main() {
  |     //find location of 33
  |     int location = find(33);
  |
  |     // if element was found 
  |     if(location != -1)
  |        printf("\nElement found at location: %d" ,(location+1));
  |     else
  |        printf("Element not found.");
  |  
  |     return 0;
  |  }
  |_________________________________________________________________________________
   
     * If we compile and run the above program, it will produce the
       result -
                 Output -
    ______________________________________
   |  Comparison 1
   |  lo : 0, list[0] = 10
   |  hi : 9, list[9] = 44
   |  mid = 6
   |
   |  Total comparisons made: 1
   |  Element found at location: 7
   |_______________________________________
     
    * You can change the search value and execute the program to test
      it.
__________________________________________________
                                                  |
        DSA - Interpolation Search                |                  
__________________________________________________|
            |
            |
1) What's the Heading ?
-----------------------
* DSA - Interpolation Search
                                                                                        
2) Definition of Interpolation Search ?
---------------------------------------
*
 
3) What is Interpolation Search About ?
---------------------------------------
*
*

4) What does Interpolation Search Do ?
--------------------------------------
*
*

5) Advantages/Benefits of Interpolation Search :
------------------------------------------------
*
*
*

6) Disadvantages/Drawback of Interpolation Search :
---------------------------------------------------
*
*
*  

7) Examples of Interpolation Search :
-------------------------------------
*
*
_______________________________________________________________________________

 4. <<<<<<<<< DSA - Hash Table >>>>>>>>>
 
   * Hash Table is a data structure which stores data in an associative
     manner.
   * In a hash table, data is stored in an array format, where each data
     value has its own unique index value.
   * Access of data becomes very fast if we know the index of the 
     desired data.  
   
   * Thus, it becomes a data structure in which insertion and search
     operations are very fast irrespective of the size of the data.
   * Hash Table uses an array as a storage medium ,
     and uses hash technique to generate an index where an element is
     to be inserted or is to be located from.
      
       ** Hashing :
          =======
   * Hashing is a technique to convert a range of key values into a
     range of indexes of an array.
   * We're going to use modulo operator to get a range of key values. 
   * Consider an example of hash table of size 20, and the following
     items are to be stored.
   * Item are in the (key,value) format.
                                                          ___________________
                                    o o                  | Index  |  Value   |
                                  o     o                |````````|``````````|
  _________                     o  Hash   o              |________|__________| 
 |  key_1  |- -_ _            o  Function  o---_ _ _---->|   0    |  value_1 | 
 |_________|      --_ _      o_ _ _ _ ------o            |________|__________| 
                        ------o  _ _ _ ----o_ _          |   1    |  value_2 |
  _________              _ _ _ -o  _ _ _ _o     --_      |________|__________|
 |  key_2  |- - _ _ _ ---        -o _ _ o - _      ----->|   2    |  value_3 | 
 |_________|                    --- o o       ---------->|________|__________|
                               -                         |   3    |  value_4 |
  _________               _ _ -                          |________|__________|
 |  key_3  |_ _ _ _ _-----
 |_________| 
         
   * (1,20)
   * (2,70)
   * (42,80)
   * (4,25)
   * (12,44)
   * (14,32)
   * (17,11)
   * (13,78)
   * (37,98)  

 _______________________________________________________________________
|   Sr.No.  |  Key   |     Hash                 |    Array Index        |
|```````````|````````|``````````````````````````|```````````````````````|
|___________|________|__________________________|_______________________|
|  1        |   1    |     1 % 20 = 1           |	  1             |
|___________|________|__________________________|_______________________|
|  2        |   2    |     2 % 20 = 2           |         2             |
|___________|________|__________________________|_______________________|
|  3        |  42    |     42 % 20 = 2          |         2             |
|___________|________|__________________________|_______________________|
|  4        |   4    |     4 % 20 = 4           |         4             |
|___________|________|__________________________|_______________________|
|  5        |  12    |     12 % 20 = 12         |        12             |
|___________|________|__________________________|_______________________|
|  6        |  14    |     14 % 20 = 14         |        14             |
|___________|________|__________________________|_______________________|
|  7        |  17    |     17 % 20 = 17         |        17             |
|___________|________|__________________________|_______________________|
|  8        |  13    |     13 % 20 = 13         |        13             |
|___________|________|__________________________|_______________________|
|  9        |  37    |     37 % 20 = 17         |        17             |
|___________|________|__________________________|_______________________|
     
    ** Linear Probing :
       ==============
  * As we can see, it may happen that the 'hashing technique' is used to
    create an already used index of the array.
  * In such a case, we can search the next empty location in the array by 
    looking into the next cell until we find an empty cell.
  * This technique is called 'linear probing'.
     
 ____________________________________________________________________________
| Sr.No. |  Key   |   Hash            |  Array Index  | After Linear Probing,
|        |        |                   |               |      Array Index
|````````|````````|```````````````````|```````````````|```````````````````````
|________|________|___________________|_______________|_______________________
|  1     |   1    |   1 % 20 = 1      |       1       |      1
|________|________|___________________|_______________|_______________________
|  2     |   2    |   2 % 20 = 2      |       2       |      2
|________|________|___________________|_______________|_______________________
|  3     |  42    |   42 % 20 = 2     |       2       |      3
|________|________|___________________|_______________|_______________________
|  4     |   4    |   4 % 20 = 4      |       4       |      4
|________|________|___________________|_______________|_______________________
|  5     |  12    |   12 % 20 = 12    |      12       |     12
|________|________|___________________|_______________|_______________________
|  6     |  14    |   14 % 20 = 14    |      14       |     14
|________|________|___________________|_______________|_______________________
|  7     |  17    |   17 % 20 = 17    |      17       |     17
|________|________|___________________|_______________|_______________________
|  8     |  13    |   13 % 20 = 13    |      13       |     13
|________|________|___________________|_______________|_______________________
|  9     |  37    |   37 % 20 = 17    |      17       |     18
|________|________|___________________|_______________|_______________________

   ** Basic Operations :
      ================
   -  basic primary operations of a hash table.
        
       a) Search − Searches an element in a hash table.
          ''''''
       b) Insert − inserts an element in a hash table.
          ''''''
       c) delete − Deletes an element from a hash table.
          ''''''
    
    ** DataItem :
       ========
  * Define a data item having some data and key, based on which the search
    is to be conducted in a hash table.
    ___________________________________
   |  struct DataItem {
   |     int data;
   |     int key;
   |  };
   |___________________________________ 
    
    ** Hash Method :
       ===========
     * Define a hashing method to compute the hash code of the key 
       of the data item.
    ______________________________
   |  int hashCode(int key){
   |     return key % SIZE;
   |  }
   |______________________________

   ** Search Operation :
      ================
  * Whenever an element is to be searched, compute the hash code of
    the key passed and locate the element using that hash code as
    index in the array.
  * Use linear probing to get the element ahead if the element
    is not found at the computed hash code.
        
        Example -
        ''''''''
    _______________________________________________________
   |  struct DataItem *search(int key) {
   |     //get the hash
   |     int hashIndex = hashCode(key);
   | 	
   |     //move in array until an empty
   |     while(hashArray[hashIndex] != NULL) {
   |	
   |        if(hashArray[hashIndex]->key == key)
   |           return hashArray[hashIndex];
   |			
   |        //go to next cell
   |        ++hashIndex;
   |    		
   |        //wrap around the table
   |        hashIndex %= SIZE;
   |     }
   |
   |     return NULL;        
   |  }
   |_________________________________________________________

     ** Insert Operation -
        ================
   * Whenever an element is to be inserted, compute the hash code of
     the key passed and locate the index using that hash code as an
     index in the array. 
   * Use linear probing for empty location, if an element is found 
     at the computed hash code.
        
        Example -
        =======
  __________________________________________________________________________________
 |  void insert(int key,int data) {
 |     struct DataItem *item = (struct DataItem*) malloc(sizeof(struct DataItem));
 |     item->data = data;  
 |     item->key = key;     
 |
 |     //get the hash 
 |     int hashIndex = hashCode(key);
 | 
 |     //move in array until an empty or deleted cell
 |     while(hashArray[hashIndex] != NULL && hashArray[hashIndex]->key != -1) {
 |        //go to next cell
 |        ++hashIndex;
 |		
 |        //wrap around the table
 |        hashIndex %= SIZE;
 |     }
 |	
 |     hashArray[hashIndex] = item;        
 |  }
 |__________________________________________________________________________________
    
       ** Delete Operation :
          ================
   * Whenever an element is to be deleted, compute the hash code of
     the key passed and locate the index using that hash code
     as an index in the array. 
   * Use linear probing to get the element ahead if an element is not found
     at the computed hash code.
   * When found, store a dummy item there to keep the performance
     of the hash table intact.
          
          Example -
          '''''''
    _________________________________________________________________
   |
   |  struct DataItem* delete(struct DataItem* item) {
   |     int key = item->key;
   |
   |     //get the hash 
   |     int hashIndex = hashCode(key);
   |
   |     //move in array until an empty 
   |     while(hashArray[hashIndex] !=NULL) {
   |	
   |        if(hashArray[hashIndex]->key == key) {
   |           struct DataItem* temp = hashArray[hashIndex]; 
   |			
   |           //assign a dummy item at deleted position
   |           hashArray[hashIndex] = dummyItem; 
   |           return temp;
   |        } 
   |		
   |        //go to next cell
   |        ++hashIndex;
   |		
   |        //wrap around the table
   |        hashIndex %= SIZE;
   |    }  
   |	
   |    return NULL;        
   |  }
   |_________________________________________________________________
     
      * about hash implementation in C programming language -
              ``````````````````````````````````````````````
         Hash Table Program in C -
         ````````````````````````
     + 'Hash Table' is a 'data structure which stores data' in an associative
       manner.
     + In 'hash table', the 'data is stored' in an 'array format' where each
       'data value' has its own unique index value.
     + Access of data becomes very fast, if we know the index of the
       desired data.
          
         Implementation of Hash Table in C -
         ```````````````````````````````````
    __________________________________________________________________________
   |  #include <stdio.h>
   |  #include <string.h>
   |  #include <stdlib.h>
   |  #include <stdbool.h>
   |
   |  #define SIZE 20
   |
   |  struct DataItem {
   |     int data;   
   |     int key;
   |  };
   |
   |  struct DataItem* hashArray[SIZE]; 
   |  struct DataItem* dummyItem;
   |  struct DataItem* item;
   |
   |  int hashCode(int key) {
   |     return key % SIZE;
   |  }
   |
   |  struct DataItem *search(int key) {
   |     //get the hash 
   |     int hashIndex = hashCode(key);  
   |	   
   |     //move in array until an empty 
   |     while(hashArray[hashIndex] != NULL) {
   |	
   |        if(hashArray[hashIndex]->key == key)
   |           return hashArray[hashIndex]; 
   |			
   |        //go to next cell
   |        ++hashIndex;
   |		
   |        //wrap around the table
   |        hashIndex %= SIZE;
   |     }        
   |	  
   |     return NULL;        
   |  }
   |
   |  void insert(int key,int data) {
   |
   |     struct DataItem *item = (struct DataItem*) malloc(sizeof(struct DataItem));
   |     item->data = data;  
   |     item->key = key;
   | 
   |     //get the hash 
   |     int hashIndex = hashCode(key);
   |
   |     //move in array until an empty or deleted cell
   |     while(hashArray[hashIndex] != NULL && hashArray[hashIndex]->key != -1) {
   |        //go to next cell
   |        ++hashIndex;
   |		
   |        //wrap around the table
   |        hashIndex %= SIZE;
   |     }
   |	
   |     hashArray[hashIndex] = item;
   |  }
   |
   |  struct DataItem* delete(struct DataItem* item) {
   |     int key = item->key;
   |
   |     //get the hash 
   |     int hashIndex = hashCode(key);
   |
   |     //move in array until an empty
   |     while(hashArray[hashIndex] != NULL) {
   |	
   |        if(hashArray[hashIndex]->key == key) {
   |           struct DataItem* temp = hashArray[hashIndex];  
   |			
   |           //assign a dummy item at deleted position
   |           hashArray[hashIndex] = dummyItem; 
   |           return temp;
   |        }
   |		
   |        //go to next cell
   |        ++hashIndex;
   |		
   |        //wrap around the table
   |        hashIndex %= SIZE;
   |     }      
   |	
   |     return NULL;        
   |  }
   |
   |  void display() {
   |     int i = 0;
   |	
   |     for(i = 0; i<SIZE; i++) {
   |	
   |        if(hashArray[i] != NULL)
   |           printf(" (%d,%d)",hashArray[i]->key,hashArray[i]->data);
   |        else
   |           printf(" ~~ ");
   |     }
   |	
   |     printf("\n");
   |  }
   |
   |  int main() {
   |     dummyItem = (struct DataItem*) malloc(sizeof(struct DataItem));
   |     dummyItem->data = -1;  
   |     dummyItem->key = -1; 
   |
   |     insert(1, 20);
   |     insert(2, 70);
   |     insert(42, 80);
   |     insert(4, 25);
   |     insert(12, 44);
   |     insert(14, 32);
   |     insert(17, 11);
   |     insert(13, 78);
   |     insert(37, 97);
   |
   |     display();
   |     item = search(37);
   |
   |     if(item != NULL) {
   |        printf("Element found: %d\n", item->data);
   |     } else {
   |        printf("Element not found\n");
   |     }
   |
   |     delete(item);
   |     item = search(37);
   |
   |     if(item != NULL) {
   |        printf("Element found: %d\n", item->data);
   |     } else {
   |        printf("Element not found\n");
   |     }
   |  }
   |___________________________________________________________________
     
      * If we compile and run the above program, it will produce the
        result -
                    Output -
 ___________________________________________________________________________________________________________________________
|
|  ~~  (1,20)  (2,70)  (42,80)  (4,25)  ~~  ~~  ~~  ~~  ~~  ~~  ~~ (12,44)  (13,78)  (14,32)  ~~  ~~  (17,11)  (37,97)  ~~ 
| Element found: 97
| Element not found 
|___________________________________________________________________________________________________________________________
__________________________________________________       
                                                  |
       DSA - Hash Table                           |                  
__________________________________________________|
            |
            |
1) What's the Heading ?
-----------------------
* DSA - Hash Table
                                                                                        
2) Definition of Hash Table ?
-----------------------------
*
 
3) What is Hash Table About ?
-----------------------------
* 
*

4) What does Hash Table Do ?
----------------------------
*
*

5) Advantages/Benefits of Hash Table :
--------------------------------------
*
*
*

6) Disadvantages/Drawback of Hash Table :
-----------------------------------------
*
*
*  

7) Examples of Hash Table :
---------------------------
*
*
_______________________________________________________________________________
        
       *** Sorting Techniques ***
           ==================
              1. DSA - Sorting Algorithms
              2. DSA - Bubble Sort
              3. DSA - Insertion Sort
              4. DSA - Selection Sort
              5. DSA - Merge Sort
              6. DSA - Shell Sort
              7. DSA - Quick Sort

     <<<<<<<<< *** Sorting Techniques *** >>>>>>>>>
                   ==================
__________________________________________________
                                                  |
       Sorting Techniques                         |                  
__________________________________________________|
            |
            |
1) What's the Heading ?
-----------------------
* Sorting Techniques
                                                                                        
2) Definition of Sorting Techniques ?
-------------------------------------
*
 
3) What is Sorting Techniques About ?
-------------------------------------
*
*

4) What does Sorting Techniques Do ?
------------------------------------
*
*

5) Advantages/Benefits of Sorting Techniques :
----------------------------------------------
*
*
*

6) Disadvantages/Drawback of Sorting Techniques :
-------------------------------------------------
*
*
*  

7) Examples of Sorting Techniques :
-----------------------------------
*
*
_______________________________________________________________________________

 1. <<<<<<<<< DSA - Sorting Algorithms >>>>>>>>>
   
    * Sorting refers to arranging data in a particular format.
    * Sorting algorithm specifies the way to arrange data in a 
      particular order. 
    * Most common orders are in numerical or lexicographical order.
 
    * The importance of sorting lies in the fact that data searching can be
      optimized to a very high level, if data is stored in a
      sorted manner.
    * Sorting is also used to represent data in more readable formats.
           
         *  some of the examples of sorting in real-life scenarios -
           
          a) Telephone Directory −
             '''''''''''''''''''
             The telephone directory stores the telephone numbers of 
             people sorted by their names, so that the names can be
             searched easily.
        
          b) Dictionary −
             ''''''''''
             The dictionary stores words in an alphabetical order so that
             searching of any word becomes easy.

    
     ** In-place Sorting and Not-in-place Sorting :
        =========================================
   * Sorting algorithms may require some extra space for comparison
     and temporary storage of few data elements. 
   * These algorithms do not require any extra space and sorting is
     said to happen in-place, or for example, within the array itself.
   * This is called "in-place sorting".
                     `````````````````
   * However, in some sorting algorithms, the program requires space
     which is more than or equal to the elements being sorted.
   * Sorting which uses equal or more space is called "not-in-place sorting".
                                                       ````````````````````
   * Merge-sort is an example of not-in-place sorting.
     
      ** Stable and Not Stable Sorting :
         =============================
   * If a sorting algorithm, after sorting the contents, does not change
     the sequence of similar content in which they appear, it is called
     "stable sorting."
      ``````````````
             
       0      1      2      3      4      5      6      7      8      9              _______________________________________________________________________
   |  ____   ____   ____   ____   ____   ____   ____   ____   ____   ____  |
   | | 35 | | 33 | | 42 | | 10 | | 14 | | 19 | | 26 | | 44 | | 26 | | 31 | |
   | |____| |____| |____| |____| |____| |____| |____| |____| |____| |____| | 
   |_______________________________________________________________________|                                                       ^             ^
                                               _-`           _-`
                                           _---          _ _ -
                                    _ _ --            _--
                             _ _-``         _ _ _ ---
                            |      |`````````
                            V      V
    _______________________________________________________________________
   |  ____   ____   ____   ____   ____   ____   ____   ____   ____   ____  |
   | | 10 | | 14 | | 19 | | 26 | | 26 | | 31 | | 33 | | 35 | | 42 | | 44 | |
   | |____| |____| |____| |____| |____| |____| |____| |____| |____| |____| | 
   |_______________________________________________________________________|             0      1      2      3      4      5      6      7      8      9
    
    * If a sorting algorithm, after sorting the contents, changes the
      sequence of similar content in which they appear, it is called 
      "unstable sorting".
       `````````````````
          0      1      2      3      4      5      6      7      8      9            _______________________________________________________________________
   |  ____   ____   ____   ____   ____   ____   ____   ____   ____   ____  |
   | | 35 | | 33 | | 42 | | 10 | | 14 | | 19 | | 26 | | 44 | | 26 | | 31 | |
   | |____| |____| |____| |____| |____| |____| |____| |____| |____| |____| | 
   |_______________________________________________________________________|                                                       ^             ^
                                               _-`           _-`
                                           _---  _ _        -
                                    _ _ _-----```            
                             _ _-``|        
                            |      |
                            V      V
    _______________________________________________________________________
   |  ____   ____   ____   ____   ____   ____   ____   ____   ____   ____  |
   | | 10 | | 14 | | 19 | | 26 | | 26 | | 31 | | 33 | | 35 | | 42 | | 44 | |
   | |____| |____| |____| |____| |____| |____| |____| |____| |____| |____| | 
   |_______________________________________________________________________|             0      1      2      3      4      5      6      7      8      9
        
   * Stability of an algorithm matters when we wish to maintain the sequence 
     of original elements, like in a tuple for example.
   
      ** Adaptive and Non-Adaptive Sorting Algorithm :
         ============================================
   * A sorting algorithm is said to be adaptive, if it takes advantage of 
     already 'sorted' elements in the list that is to be sorted. 
   * That is, while sorting if the source list has some element 
     already sorted, adaptive algorithms will take this into account
     and will try not to re-order them.
   
   * A non-adaptive algorithm is one which does not take into account the
     elements which are already sorted.
   * They try to force every single element to be re-ordered to 
     confirm their sortedness.
         
      ++ Important Terms -
         ``````````````````
  * Some terms are generally coined while discussing sorting techniques,
    here is a brief introduction to them −
          
       a) Increasing Order -
          ````````````````
     * A sequence of values is said to be in increasing order, if the
       successive element is greater than the previous one.
     * For example, 1, 3, 4, 6, 8, 9 are in increasing order,
       as every next element is greater than the previous element.

       b) Decreasing Order -
          ````````````````
     * A sequence of values is said to be in decreasing order, if the
       successive element is less than the current one.
     * For example, 9, 8, 6, 4, 3, 1 are in decreasing order, as every next
       element is less than the previous element.
      
       c) Non-Increasing Order -
          ````````````````````
     * A sequence of values is said to be in non-increasing order, if the
       successive element is less than or equal to its previous
       element in the sequence. 
     * This order occurs when the sequence contains duplicate values.
     * For example, 9, 8, 6, 3, 3, 1 are in non-increasing order, as every
       next element is less than or equal to (in case of 3) but not
       greater than any previous element.

       d) Non-Decreasing Order -
          ````````````````````
     * A sequence of values is said to be in non-decreasing order, if the
       successive element is greater than or equal to its previous element 
       in the sequence. 
     * This order occurs when the sequence contains duplicate values.
     * For example, 1, 3, 3, 6, 8, 9 are in non-decreasing order, as
       every next element is greater than or equal to (in case of 3)
       but not less than the previous one.
__________________________________________________
                                                  |
       DSA - Sorting Algorithms                   |                  
__________________________________________________|
            |
            |
1) What's the Heading ?
-----------------------
* DSA - Sorting Algorithms
                                                                                        
2) Definition of Sorting Algorithms ?
-------------------------------------
*
 
3) What is Sorting Algorithms About ?
-------------------------------------
*
*

4) What does Sorting Algorithms Do ?
------------------------------------
*
*

5) Advantages/Benefits of Sorting Algorithms :
----------------------------------------------
*
*
*

6) Disadvantages/Drawback of Sorting Algorithms :
-------------------------------------------------
*
*
*  

7) Examples of Sorting Algorithms :
-----------------------------------
*
*
______________________________________________________________________________

 2. <<<<<<<<< DSA - Bubble Sort >>>>>>>>>
    
    * Bubble sort is a simple sorting algorithm. 
    * This sorting algorithm is comparison-based algorithm in which
      each pair of adjacent elements is compared and  the elements are 
      swapped if they are not in order.
    * This algorithm is not suitable for large data sets as its average
      and worst case complexity are of Ο(n2) where n is the
      number of items.                 '''''      '''
        
        ** How Bubble Sort Works ?
           =====================
    * We take an unsorted array for our example.
    * Bubble sort takes Ο(n2) time so we're keeping it short and precise.
      ```````````       ''''' ````  
          ____   ____   ____   ____   ____ 
         | 14 | | 33 | | 27 | | 35 | | 10 |
         |____| |____| |____| |____| |____| 
    
    * Bubble sort starts with very first two elements, comparing them 
      to check which one is greater. 
          ____   ____   ____   ____   ____ 
         |/14/| |/33/| | 27 | | 35 | | 10 |
         |////| |////| |____| |____| |____|

    * In this case, value 33 is greater than 14, so it is already in
      sorted locations.
    * Next, we compare 33 with 27.
          
          ____   ____   ____   ____   ____ 
         | 14 | |/33/| |/27/| | 35 | | 10 |
         |____| |////| |////| |____| |____|
    
     * We find that 27 is smaller than 33 and these two values
       must be swapped.
         
          ____   ____   ____   ____   ____ 
         | 14 | |:33:| |:27:| | 35 | | 10 |
         |____| |::::| |::::| |____| |____|
      
     * The new array should look like this −
          ____   ____   ____   ____   ____ 
         | 14 | | 27 | | 33 | | 35 | | 10 |
         |____| |____| |____| |____| |____| 
     
     * Next we compare 33 and 35.
     * We find that both are in already sorted positions.
       
          ____   ____   ____   ____   ____ 
         | 14 | | 27 | | 33 | |/35/| |/10/|
         |____| |____| |____| |////| |////|
       
     * Then we move to the next two values, 35 and 10.
         
         
          ____   ____   ____   ____   ____ 
         | 14 | | 27 | | 33 | |:35:| |:10:|
         |____| |____| |____| |::::| |::::|
      
     * We swap these values.
     * We find that we have reached the end of the array.
     * After one iteration, the array should look like this −
     
          ____   ____   ____   ____   ____ 
         | 14 | | 27 | | 33 | | 10 | |*35*|
         |____| |____| |____| |____| |****| 
     
     * To be precise, we are now showing how an array should look 
       like after each iteration.
     * After the second iteration, it should look like this −
   
          ____   ____   ____   ____   ____ 
         | 14 | | 27 | | 10 | |*33*| |*35*|
         |____| |____| |____| |****| |****|  
     
      * Notice that after each iteration, at least one value moves at the end. 
     
          ____   ____   ____   ____   ____ 
         | 14 | | 10 | |*27*| |*33*| |*35*|
         |____| |____| |****| |****| |****| 
        
      * And when there's no swap required, bubble sorts learns that
        an array is completely sorted.
          
          ____   ____   ____   ____   ____ 
         |*10*| |*14*| |*27*| |*33*| |*35*|
         |****| |****| |****| |****| |****|
       
      * Now we should look into some practical aspects of bubble sort.
          
         + Algorithm -
           ```````````` 
    * We assume list is an array of n elements.
    * We further assume that swap function swaps the values of
      the given array elements.
      ________________________________________________
     |  begin BubbleSort(list)
     | 
     |     for all elements of list
     |        if list[i] > list[i+1]
     |           swap(list[i], list[i+1])
     |        end if
     |     end for
     |
     |     return list
     | 
     |  end BubbleSort
     |_________________________________________________
      
      ** Pseudocode :
         =-=-=-=-=-
    * We observe in algorithm that Bubble Sort compares each pair of array
      element unless the whole array is completely sorted in an 
      ascending order.
    * This may cause a few complexity issues like what if the array
      needs no more swapping as all the elements are already ascending.
     
    * To ease-out the issue, we use one flag variable swapped which
      will help us see if any swap has happened or not.
    * If no swap has occurred, i.e. the array requires no more processing
      to be sorted, it will come out of the loop.

    * Pseudocode of BubbleSort algorithm can be written as follows −
      ``````````    `````````````````````
    ___________________________________________________________________
   |
   |  procedure bubbleSort( list : array of items )
   |
   |     loop = list.count;
   |
   |     for i = 0 to loop-1 do:
   |        swapped = false
   |		
   |        for j = 0 to loop-1 do:
   |   
   |           /* compare the adjacent elements */   
   |           if list[j] > list[j+1] then
   |              /* swap them */
   |              swap( list[j], list[j+1] )		 
   |              swapped = true
   |           end if
   |      
   |        end for
   |   
   |        /*if no number was swapped that means 
   |        array is sorted now, break the loop.*/
   |        
   |        if(not swapped) then
   |           break
   |        end if
   |       
   |     end for
   | 
   |  end procedure return list
   |__________________________________________________________
        
     + Implementation of Bubblesort Algorithm -
       `````````````````````````````````````````
   * One more issue we did not address in our original algorithm and its
     improvised pseudocode, is that, after every iteration the highest 
     values settles down at the end of the array.
   * Hence, the next iteration need not include already sorted elements.
   * For this purpose, in our implementation, we restrict the inner loop
     to avoid already sorted values.

       ++ Bubble sort implementation in C programming language :
          ```````````````````````````````````````````````````````

       ++ Bubble Sort Program in C :
          ```````````````````````````
    ___________________________________________________________________
   |
   |  #include <stdio.h>
   |  #include <stdbool.h>
   |
   |  #define MAX 10
   |
   |  int list[MAX] = {1,8,4,6,0,3,5,2,7,9};
   | 
   |  void display() {
   |     int i;
   |     printf("[");
   |	
   |     // navigate through all items 
   |     for(i = 0; i < MAX; i++) {
   |        printf("%d ",list[i]);
   |     }
   |    	
   |     printf("]\n");
   |  }
   |
   |  void bubbleSort() {
   |     int temp;
   |     int i,j;
   |	
   |     bool swapped = false;
   | 
   |     // loop through all numbers 
   |     for(i = 0; i < MAX-1; i++) { 
   |        swapped = false;
   | 		
   |        // loop through numbers falling ahead 
   |        for(j = 0; j < MAX-1-i; j++) {
   |           printf("     Items compared: [ %d, %d ] ", list[j],list[j+1]);
   |
   |           // check if next number is lesser than current no
   |           //   swap the numbers. 
   |           //  (Bubble up the highest number)
   |			
   |           if(list[j] > list[j+1]) {
   |              temp = list[j];
   |              list[j] = list[j+1];
   |              list[j+1] = temp;
   |
   |              swapped = true;
   |              printf(" => swapped [%d, %d]\n",list[j],list[j+1]);
   |           } else {
   |              printf(" => not swapped\n");
   |           }
   |			
   |        }
   |  
   |        // if no number was swapped that means 
   |        //   array is sorted now, break the loop. 
   |        if(!swapped) {
   |          break;
   |        }
   |      
   |        printf("Iteration %d#: ",(i+1)); 
   |        display();
   |     }
   |	
   |  }
   |
   |  void main() {
   |     printf("Input Array: ");
   |     display();
   |     printf("\n");
   |	
   |     bubbleSort();
   |     printf("\nOutput Array: ");
   |     display();
   |  }
   |________________________________________________________________________

    * If we compile and run the above program, it will produce the following
      result -
                  Output -
    ________________________________________________________________________
   |
   |  Input Array: [1 8 4 6 0 3 5 2 7 9 ]
   |       Items compared: [ 1, 8 ]  => not swapped
   |       Items compared: [ 8, 4 ]  => swapped [4, 8]
   |       Items compared: [ 8, 6 ]  => swapped [6, 8]
   |       Items compared: [ 8, 0 ]  => swapped [0, 8]
   |       Items compared: [ 8, 3 ]  => swapped [3, 8]
   |       Items compared: [ 8, 5 ]  => swapped [5, 8]
   |       Items compared: [ 8, 2 ]  => swapped [2, 8]
   |       Items compared: [ 8, 7 ]  => swapped [7, 8]
   |       Items compared: [ 8, 9 ]  => not swapped
   |  Iteration 1#: [1 4 6 0 3 5 2 7 8 9 ]
   |       Items compared: [ 1, 4 ]  => not swapped
   |       Items compared: [ 4, 6 ]  => not swapped
   |       Items compared: [ 6, 0 ]  => swapped [0, 6]
   |       Items compared: [ 6, 3 ]  => swapped [3, 6]
   |       Items compared: [ 6, 5 ]  => swapped [5, 6]
   |       Items compared: [ 6, 2 ]  => swapped [2, 6]
   |       Items compared: [ 6, 7 ]  => not swapped
   |       Items compared: [ 7, 8 ]  => not swapped
   |  Iteration 2#: [1 4 0 3 5 2 6 7 8 9 ]
   |       Items compared: [ 1, 4 ]  => not swapped
   |       Items compared: [ 4, 0 ]  => swapped [0, 4]
   |       Items compared: [ 4, 3 ]  => swapped [3, 4]
   |       Items compared: [ 4, 5 ]  => not swapped
   |       Items compared: [ 5, 2 ]  => swapped [2, 5]
   |       Items compared: [ 5, 6 ]  => not swapped
   |       Items compared: [ 6, 7 ]  => not swapped
   |  Iteration 3#: [1 0 3 4 2 5 6 7 8 9 ]
   |       Items compared: [ 1, 0 ]  => swapped [0, 1]
   |       Items compared: [ 1, 3 ]  => not swapped
   |       Items compared: [ 3, 4 ]  => not swapped
   |       Items compared: [ 4, 2 ]  => swapped [2, 4]
   |       Items compared: [ 4, 5 ]  => not swapped
   |       Items compared: [ 5, 6 ]  => not swapped
   |  Iteration 4#: [0 1 3 2 4 5 6 7 8 9 ]
   |       Items compared: [ 0, 1 ]  => not swapped
   |       Items compared: [ 1, 3 ]  => not swapped
   |       Items compared: [ 3, 2 ]  => swapped [2, 3]
   |       Items compared: [ 3, 4 ]  => not swapped
   |       Items compared: [ 4, 5 ]  => not swapped
   |  Iteration 5#: [0 1 2 3 4 5 6 7 8 9 ]
   |       Items compared: [ 0, 1 ]  => not swapped
   |       Items compared: [ 1, 2 ]  => not swapped
   |       Items compared: [ 2, 3 ]  => not swapped
   |       Items compared: [ 3, 4 ]  => not swapped
   |
   |  Output Array: [0 1 2 3 4 5 6 7 8 9 ]
   |________________________________________________________________________
__________________________________________________
                                                  |
      DSA - Bubble Sort                           |                  
__________________________________________________|
            |
            |
1) What's the Heading ?
-----------------------
* DSA - Bubble Sort
                                                                                        
2) Definition of Bubble Sort ?
------------------------------
*
 
3) What is Bubble Sort About ?
------------------------------
*
*

4) What does Bubble Sort Do ?
-----------------------------
*
*

5) Advantages/Benefits of Bubble Sort :
---------------------------------------
*
*
*

6) Disadvantages/Drawback of Bubble Sort :
------------------------------------------
*
*
*  

7) Examples of Bubble Sort :
----------------------------
*
*
_______________________________________________________________________________

 3. <<<<<<<<< DSA - Insertion Sort >>>>>>>>>
  
     * This is an in-place comparison-based sorting algorithm.
     * Here, a sub-list is maintained which is always sorted.
     * For example, the lower part of an array is maintained to be sorted. 
     * An element which is to be 'insert'ed in this sorted sub-list,
       has to find its appropriate place and then it has to be
       inserted there.
     * Hence the name, "insertion sort".
                        ``````````````
     * The array is searched sequentially and unsorted items are moved and
       inserted into the sorted sub-list (in the same array).
     * This algorithm is not suitable for large data sets as its average
       and worst case complexity are of Ο(n2), where n is the number 
       of items.                        '''''       '''
                    
              ** How Insertion Sort Works ? 
                 ========================
     * We take an unsorted array for our example -
      ____   ____   ____   ____   ____   ____   ____   ____    
     | 14 | | 33 | | 27 | | 10 | | 35 | | 19 | | 42 | | 44 |
     |____| |____| |____| |____| |____| |____| |____| |____| 
       
     * Insertion sort compares the first two elements -
      ____   ____   ____   ____   ____   ____   ____   ____ 
     ||14|| ||33|| | 27 | | 10 | | 35 | | 19 | | 42 | | 44 | 
     |||||| |||||| |____| |____| |____| |____| |____| |____| 
     
     * It finds that both 14 and 33 are already in ascending order.
     * For now, 14 is in sorted sub-list.
      ____   ____   ____   ____   ____   ____   ____   ____ 
     |/14/| | 33 | | 27 | | 10 | | 35 | | 19 | | 42 | | 44 | 
     |////| |____| |____| |____| |____| |____| |____| |____| 
     
     * Insertion sort moves ahead and compares 33 with 27.
      ____   ____   ____   ____   ____   ____   ____   ____ 
     |/14/| ||33|| ||27|| | 10 | | 35 | | 19 | | 42 | | 44 | 
     |////| |||||| |||||| |____| |____| |____| |____| |____| 
     
     * And finds that 33 is not in the correct position.
      ____   ____   ____   ____   ____   ____   ____   ____ 
     |/14/| |-33-| ||27|| | 10 | | 35 | | 19 | | 42 | | 44 | 
     |////| |----| |||||| |____| |____| |____| |____| |____| 

     * It swaps 33 with 27.
     * It also checks with all the elements of sorted sub-list.
     * Here we see that the sorted sub-list has only one element 14,
       and 27 is greater than 14.
     * Hence, the sorted sub-list remains sorted after swapping.
        
      ____   ____   ____   ____   ____   ____   ____   ____ 
     |/14/| |/27/| | 33 | | 10 | | 35 | | 19 | | 42 | | 44 | 
     |////| |////| |____| |____| |____| |____| |____| |____|
     
     * By now we have 14 and 27 in the sorted sub-list. 
     * Next, it compares 33 with 10. 
      ____   ____   ____   ____   ____   ____   ____   ____ 
     |/14/| |/27/| ||33|| ||10|| | 35 | | 19 | | 42 | | 44 | 
     |////| |////| |||||| |||||| |____| |____| |____| |____| 
  
     * These values are not in a sorted order.  
      ____   ____   ____   ____   ____   ____   ____   ____ 
     |/14/| |/27/| |-33-| ||10|| | 35 | | 19 | | 42 | | 44 | 
     |////| |////| |----| |||||| |____| |____| |____| |____|
 
     * So we swap them.
      
      ____   ____   ____   ____   ____   ____   ____   ____ 
     |/14/| |/27/| |/10/| | 33 | | 35 | | 19 | | 42 | | 44 | 
     |////| |////| |////| |____| |____| |____| |____| |____|
     
     * However, swapping makes 27 and 10 unsorted.
   
      ____   ____   ____   ____   ____   ____   ____   ____ 
     |/14/| |-27-| |-10-| | 33 | | 35 | | 19 | | 42 | | 44 | 
     |////| |----| |----| |____| |____| |____| |____| |____|
      
     * Hence, we swap them too. 
     
      ____   ____   ____   ____   ____   ____   ____   ____ 
     |/14/| |/10/| |/27/| | 33 | | 35 | | 19 | | 42 | | 44 | 
     |////| |////| |////| |____| |____| |____| |____| |____|
    
     * Again we find 14 and 10 in an unsorted order.
     
      ____   ____   ____   ____   ____   ____   ____   ____ 
     |-14-| |-10-| ||27|| | 33 | | 35 | | 19 | | 42 | | 44 | 
     |----| |----| |||||| |____| |____| |____| |____| |____|
      
     * We swap them again.
     * By the end of third iteration, we have a sorted
       sub-list of 4 items.
     
      ____   ____   ____   ____   ____   ____   ____   ____ 
     |/10/| |/14/| |/27/| | 33 | | 35 | | 19 | | 42 | | 44 |
     |////| |////| |////| |____| |____| |____| |____| |____|
    
     * This process goes on until all the unsorted values are covered in a
       sorted sub-list.
     * Now we shall see some programming aspects of insertion sort.
         
         + Algorithm -
           ````````````
     * Now we have a bigger picture of how this sorting technique works, so
       we can derive simple steps by which we can achieve insertion sort.
       
    _________________________________________________________________________
   |  Step 1 − If it is the first element, it is already sorted. return 1;
   |  Step 2 − Pick next element
   |  Step 3 − Compare with all elements in the sorted sub-list
   |  Step 4 − Shift all the elements in the sorted sub-list that is greater than the 
   |           value to be sorted
   |  Step 5 − Insert the value
   |  Step 6 − Repeat until list is sorted
   |___________________________________________________________________

      * Pseudocode -
        ''''''''''''''
   ____________________________________________________________________
  |
  |  procedure insertionSort( A : array of items )
  |     int holePosition
  |     int valueToInsert
  |	
  |     for i = 1 to length(A) inclusive do:
  |	
  |        /* select value to be inserted */
  |        valueToInsert = A[i]
  |        holePosition = i
  |    
  |        /*locate hole position for the element to be inserted */
  |		
  |        while holePosition > 0 and A[holePosition-1] > valueToInsert do:
  |           A[holePosition] = A[holePosition-1]
  |           holePosition = holePosition -1
  |        end while
  |		
  |        /* insert the number at hole position */
  |        A[holePosition] = valueToInsert
  |    
  |     end for
  |	
  |  end procedure
  |____________________________________________________________________ 
      
     * about insertion sort implementation in C programming -  
             `````````````````````````````
     * Insertion Sort Program in C -
       `````````````````````````````` 
      + This is an in-place comparison-based sorting algorithm.
      + Here, a sub-list is maintained which is always sorted.
      + An element which is to be 'insert'ed in this sorted sub-list,
        has to find its appropriate place and then it is to be 
        inserted there.
      + Hence the name insertion sort.
         
      - Implementation in C -
   __________________________________________________________________________
  |  #include <stdio.h>
  |  #include <stdbool.h>
  |
  |  #define MAX 7
  | 
  |  int intArray[MAX] = {4,6,3,2,1,9,7};
  |
  |  void printline(int count) {
  |     int i;
  |	
  |     for(i = 0;i < count-1;i++) {
  |        printf("=");
  |     }
  |	
  |     printf("=\n");
  |  }
  |
  |  void display() {
  |     int i;
  |     printf("[");
  |    	
  |     // navigate through all items 
  |     for(i = 0;i < MAX;i++) {
  |        printf("%d ",intArray[i]);
  |     }
  |	
  |     printf("]\n");
  |  }
  |
  |  void insertionSort() {
  |
  |     int valueToInsert;
  |     int holePosition;
  |     int i;
  |
  |     // loop through all numbers 
  |     for(i = 1; i < MAX; i++) { 
  |	
  |        // select a value to be inserted. 
  |        valueToInsert = intArray[i];
  |		
  |        // select the hole position where number is to be inserted 
  |        holePosition = i;
  |		
  |        // check if previous no. is larger than value to be inserted 
  |        while (holePosition > 0 && intArray[holePosition-1] > valueToInsert) {
  |           intArray[holePosition] = intArray[holePosition-1];
  |           holePosition--;
  |           printf(" item moved : %d\n" , intArray[holePosition]);
  |        }
  |
  |        if(holePosition != i) {
  |           printf(" item inserted : %d, at position : %d\n" , valueToInsert,holePosition);
  |           // insert the number at hole position 
  |           intArray[holePosition] = valueToInsert;
  |        }
  |
  |        printf("Iteration %d#:",i);
  |        display();
  |		
  |     }  
  |  }
  |
  |  void main() {
  |     printf("Input Array: ");
  |     display();
  |     printline(50);
  |     insertionSort();
  |     printf("Output Array: ");
  |     display();
  |     printline(50);
  |  }
  |___________________________________________________________________________
      
     * If we compile and run the above program, it will produce the following
       result -
                Output -
    ____________________________________________________________________
   |
   |  Input Array: [4 6 3 2 1 9 7 ]
   |  ==================================================
   |  Iteration 1#:[4 6 3 2 1 9 7 ]
   |   item moved : 6
   |   item moved : 4
   |   item inserted : 3, at position : 0
   |  Iteration 2#:[3 4 6 2 1 9 7 ]
   |   item moved : 6
   |   item moved : 4
   |   item moved : 3
   |   item inserted : 2, at position : 0
   |  Iteration 3#:[2 3 4 6 1 9 7 ]
   |   item moved : 6
   |   item moved : 4
   |   item moved : 3
   |   item moved : 2
   |   item inserted : 1, at position : 0
   |  Iteration 4#:[1 2 3 4 6 9 7 ]
   |  Iteration 5#:[1 2 3 4 6 9 7 ]
   |   item moved : 9
   |   item inserted : 7, at position : 5
   |  Iteration 6#:[1 2 3 4 6 7 9 ]
   |  Output Array: [1 2 3 4 6 7 9 ]
   |  ================================================== 
   |_____________________________________________________________________
__________________________________________________
                                                  |
       DSA - Insertion Sort                       |                  
__________________________________________________|
            |
            |
1) What's the Heading ?
-----------------------
* DSA - Insertion Sort
                                                                                        
2) Definition of Insertion Sort ?
---------------------------------
*
 
3) What is Insertion Sort About ?
---------------------------------
*
*

4) What does Insertion Sort Do ?
--------------------------------
*
*

5) Advantages/Benefits of Insertion Sort :
------------------------------------------
*
*
*

6) Disadvantages/Drawback of Insertion Sort :
---------------------------------------------
*
*
*  

7) Examples of Insertion Sort :
-------------------------------
*
*
_______________________________________________________________________________

 4. <<<<<<<<< DSA - Selection Sort >>>>>>>>>
     
     * Selection sort is a simple sorting algorithm.
     * This sorting algorithm is an in-place comparison-based algorithm
       in which the list is divided into two parts, the sorted part at 
       at the left end and the unsorted part at the right end.
     * Initially, the sorted part is empty and the unsorted part is the
       entire list.
     
     * The smallest element is selected from the unsorted array and swapped
       with the leftmost element, and that element becomes a part of the
       sorted array.
     * This process continues moving unsorted array boundary by one
       element to the right.
     
     * This algorithm is not suitable for large data sets as its average
       and worst case complexities are of Ο(n2), where n is the 
       number of items.                   '''''       '''
      
         ** How Selection Sort Works ?
            ========================
    - Consider the following depicted array as an example.  
         
      ____   ____   ____   ____   ____   ____   ____   ____ 
     | 14 | | 33 | | 27 | | 10 | | 35 | | 19 | | 42 | | 44 |
     |____| |____| |____| |____| |____| |____| |____| |____|  
     
      * For the first position in the sorted list, the whole list is scanned
        sequentially.
      * The first position where 14 is stored presently, we search
        the whole list and find that 10 is the lowest value.
     
      ____   ____   ____   ____   ____   ____   ____   ____ 
     ||14|| | 33 | | 27 | |/10/| | 35 | | 19 | | 42 | | 44 |
     |||||| |____| |____| |////| |____| |____| |____| |____| 
      
      * So we replace 14 with 10. 
      * After one iteration 10, which happens to be the minimum value
        in the list, appears in the first position of the sorted list.
     
      ____   ____   ____   ____   ____   ____   ____   ____ 
     ||10|| | 33 | | 27 | | 10 | | 35 | | 19 | | 42 | | 44 |
     |||||| |____| |____| |____| |____| |____| |____| |____| 
     
      * For the second position, where 33 is residing, we start scanning
        the rest of the list in a linear manner.
     
      ____   ____   ____   ____   ____   ____   ____   ____ 
     ||10|| |/33/| | 27 | | 10 | | 35 | | 19 | | 42 | | 44 |
     |||||| |////| |____| |____| |____| |____| |____| |____| 

      * We find that 14 is the second lowest value in the list and it should
        appear at the second place.
      * We swap these values -
      ____   ____   ____   ____   ____   ____   ____   ____ 
     ||10|| |/33/| | 27 | |-14-| | 35 | | 19 | | 42 | | 44 |
     |||||| |////| |____| |----| |____| |____| |____| |____| 
     
      * After two iterations, two least values are positioned at 
        the beginning in a sorted manner.
     
      ____   ____   ____   ____   ____   ____   ____   ____ 
     ||10|| ||14|| | 27 | | 33 | | 35 | | 19 | | 42 | | 44 |
     |||||| |||||| |____| |____| |____| |____| |____| |____| 

      * The same process is applied to the rest of the items in the array.
      
      * Following is a pictorial depiction of the entire sorting process −
    
      ____   ____   ____   ____   ____   ____   ____   ____ 
     ||10|| ||14|| |/27/| | 33 | | 35 | | 19 | | 42 | | 44 |
     |||||| |||||| |////| |____| |____| |____| |____| |____|
     
      ____   ____   ____   ____   ____   ____   ____   ____ 
     ||10|| ||14|| |/27/| | 33 | | 35 | |-19-| | 42 | | 44 |
     |||||| |||||| |////| |____| |____| |----| |____| |____|  
     
      ____   ____   ____   ____   ____   ____   ____   ____ 
     ||10|| ||14|| ||19|| |/33/| | 35 | | 19 | | 42 | | 44 |
     |||||| |||||| |||||| |////| |____| |____| |____| |____|
     
      ____   ____   ____   ____   ____   ____   ____   ____ 
     ||10|| ||14|| ||19|| |/33/| | 35 | |-27-| | 42 | | 44 |
     |||||| |||||| |||||| |////| |____| |----| |____| |____|  
     
      ____   ____   ____   ____   ____   ____   ____   ____ 
     ||10|| ||14|| ||19|| ||27|| | 35 | | 19 | | 42 | | 44 |
     |||||| |||||| |||||| |||||| |____| |____| |____| |____| 
     
      ____   ____   ____   ____   ____   ____   ____   ____ 
     ||10|| ||14|| ||19|| ||27|| |/35/| | 19 | | 42 | | 44 |
     |||||| |||||| |||||| |||||| |////| |____| |____| |____|
     
      ____   ____   ____   ____   ____   ____   ____   ____ 
     ||10|| ||14|| ||19|| ||27|| |/35/| |-33-| | 42 | | 44 |
     |||||| |||||| |||||| |||||| |////| |----| |____| |____|  
     
      ____   ____   ____   ____   ____   ____   ____   ____ 
     ||10|| ||14|| ||19|| ||27|| ||33|| | 35 | | 42 | | 44 |
     |||||| |||||| |||||| |||||| |||||| |____| |____| |____|
     
      ____   ____   ____   ____   ____   ____   ____   ____ 
     ||10|| ||14|| ||19|| ||27|| ||33|| ||35|| ||42|| ||44||
     |||||| |||||| |||||| |||||| |||||| |||||| |||||| ||||||  

       
      * Now, let us learn some programming aspects of selection sort.
     
         + Algorithm -
           ````````````
    __________________________________________________________
   | 
   |  Step 1 − Set MIN to location 0
   |  Step 2 − Search the minimum element in the list
   |  Step 3 − Swap with value at location MIN
   |  Step 4 − Increment MIN to point to next element
   |  Step 5 − Repeat until list is sorted
   |__________________________________________________________
         
         + Pseudocode -
           `````````````
    ____________________________________________________________________
   |
   |  procedure selection sort 
   |     list  : array of items
   |     n     : size of list
   | 
   |     for i = 1 to n - 1
   |     /* set current element as minimum*/
   |        min = i    
   |
   |        /* check the element to be minimum */
   |
   |        for j = i+1 to n 
   |           if list[j] < list[min] then
   |              min = j;
   |           end if
   |        end for
   |     
   |        /* swap the minimum element with the current element*/
   |        if indexMin != i  then
   |           swap list[min] and list[i]
   |        end if
   |     end for
   |	
   |  end procedure
   |_____________________________________________________________________
       
      * About selection sort implementation in C programming language -
              `````````````````````````````    ```````````````````````
      * Selection Sort Program in C -
        ```````````````````````````
     + Selection sort is a simple sorting algorithm.
     + This sorting algorithm is an in-place comparison-based algorithm
       in which the list is divided into two parts, the sorted part at the left 
       end and the unsorted part at the right end.
     + Initially, the 'sorted' part is empty and the 'unsorted' part is the
       entire list.    ``````                         ````````
            
          + Implementation in C -
            `````````````````````
   ____________________________________________________________________
  |  #include <stdio.h>
  |  #include <stdbool.h>
  |
  |  #define MAX 7
  | 
  |  int intArray[MAX] = {4,6,3,2,1,9,7};
  |
  |  void printline(int count) {
  |     int i;
  |	 
  |     for(i = 0;i < count-1;i++) {
  |        printf("=");
  |     }
  |	
  |     printf("=\n");
  |  }
  |
  |  void display() {
  |     int i;
  |     printf("[");
  |	
  |     // navigate through all items 
  |     for(i = 0;i < MAX;i++) {
  |        printf("%d ", intArray[i]);
  |     }
  |   	
  |     printf("]\n");
  |  }
  |
  |  void selectionSort() {
  |     int indexMin,i,j;
  |	
  |     // loop through all numbers 
  |     for(i = 0; i < MAX-1; i++) {  
  | 	
  |        // set current element as minimum 
  |        indexMin = i;
  |		
  |        // check the element to be minimum 
  |        for(j = i+1;j < MAX;j++) {
  |           if(intArray[j] < intArray[indexMin]) {
  |              indexMin = j;
  |           }
  |        }
  |
  |        if(indexMin != i) {
  |           printf("Items swapped: [ %d, %d ]\n" , intArray[i], intArray[indexMin]); 
  |			
  |           // swap the numbers 
  |           int temp = intArray[indexMin];
  |           intArray[indexMin] = intArray[i];
  |           intArray[i] = temp;
  |        }          
  |   
  |        printf("Iteration %d#:",(i+1));
  |        display();
  |     }
  |  }  
  |
  |  void main() {
  |     printf("Input Array: ");
  |     display();
  |     printline(50);
  |     selectionSort();
  |     printf("Output Array: ");
  |     display();
  |     printline(50);
  |  }
  |__________________________________________________________________________ 
     
       * If we compile and run the above program, it will produce the following
         result -
                     Output -  
    ____________________________________________________________
   |
   |  Input Array: [4 6 3 2 1 9 7 ]
   |  ==================================================
   |  Items swapped: [ 4, 1 ]
   |  Iteration 1#:[1 6 3 2 4 9 7 ]
   |  Items swapped: [ 6, 2 ]
   |  Iteration 2#:[1 2 3 6 4 9 7 ]
   |  Iteration 3#:[1 2 3 6 4 9 7 ]
   |  Items swapped: [ 6, 4 ]
   |  Iteration 4#:[1 2 3 4 6 9 7 ]
   |  Iteration 5#:[1 2 3 4 6 9 7 ]
   |  Items swapped: [ 9, 7 ]
   |  Iteration 6#:[1 2 3 4 6 7 9 ]
   |  Output Array: [1 2 3 4 6 7 9 ]
   |  ==================================================
   |_____________________________________________________________ 
__________________________________________________
                                                  |
        DSA - Selection Sort                      |                  
__________________________________________________|
            |
            |
1) What's the Heading ?
-----------------------
* DSA - Selection Sort
                                                                                        
2) Definition of Selection Sort ?
---------------------------------
* 
 
3) What is Selection Sort About ?
---------------------------------
*
*

4) What does Selection Sort Do ?
--------------------------------
*
*

5) Advantages/Benefits of Selection Sort :
------------------------------------------
*
*
*

6) Disadvantages/Drawback of Selection Sort :
---------------------------------------------
*
*
*  

7) Examples of Selection Sort :
-------------------------------
*
*
________________________________________________________________________________

 5. <<<<<<<<< DSA - Merge Sort >>>>>>>>>
    
    * "Merge sort" is a 'sorting technique' based on 'divide and conquer'
      technique.
    * With worst-case 'time complexity' being Ο(n log n), it is one of the
      the most respected algorithms.          ``````````
    
    * 'Merge sort' first 'divides' the 'array' into 'equal halves' and then 
      combines them in a sorted manner.
      
        ** How Merge Sort Works ?
           ====================
   * To understand merge sort, we take an unsorted array as the following −
         
      ____   ____   ____   ____   ____   ____   ____   ____ 
     | 14 | | 33 | | 27 | | 10 | | 35 | | 19 | | 42 | | 44 |
     |____| |____| |____| |____| |____| |____| |____| |____| 
   
  * We know that merge sort first divides the whole array iteratively into
    equal halves unless the atomic values are achieved.
  * We see here that an array of 8 items is divided into two arrays
    of size 4.
     
      ____   ____   ____   ____       ____   ____   ____   ____ 
     | 14 | | 33 | | 27 | | 10 |     | 35 | | 19 | | 42 | | 44 |
     |____| |____| |____| |____|     |____| |____| |____| |____| 
   
   * This does not change the sequence of appearance of items
     in the original.
   * Now we divide these two arrays into halves.
    ______________                                     ______________
   |//____  ____//|    ____  ____       ____  ____    |..____  ____..| 
   |/| 14 || 33 |/|   | 27 || 10 |     | 35 || 19 |   |.| 42 || 44 |.| 
   |/|____||____|/|   |____||____|     |____||____|   |.|____||____|.| 
   |//////////////|                                   |..............|
    
   * We further divide these arrays and we achieve atomic value which can
     no more be divided.
    ________   ________                                ________   ________
   |//____//| |//____//|  ____   ____    ____   ____  |..____..| |..____..|
   |/| 14 |/| |/| 33 |/| | 27 | | 10 |  | 35 | | 19 | |.| 42 |.| |.| 44 |.|
   |/|____|/| |/|____|/| |____| |____|  |____| |____| |.|____|.| |.|____|.|
   |////////| |////////|                              |........| |........|
  
   * Now, we combine them in exactly the same manner as they were broke 
     down. 
   * Please note the color codes given to these lists.
   
   * We first compare the element for each list and then combine them into
     another list in a sorted manner.
   * We see that 14 and 33 are in sorted positions.
   * We compare 27 and 10 and in the target list of 2 values we put 
     10 first, followed by 27.
   * We change the order of 19 and 35 whereas 42 and 44 are placed
     sequentially.
       
    ______________                                     ______________
   |//____  ____//|    ____  ____       ____  ____    |..____  ____..| 
   |/| 14 || 33 |/|   | 10 || 27 |     | 19 || 35 |   |.| 42 || 44 |.| 
   |/|____||____|/|   |____||____|     |____||____|   |.|____||____|.| 
   |//////////////|                                   |..............|
   
   * In the next iteration of the combining phase, we compare lists of two
     data values, and merge them into a list of found data
     values placing all in a sorted order.
                                      _____________________________
      ____   ____   ____   ____      |..____   ____   ____   ____..|
     | 10 | | 14 | | 27 | | 33 |     |.| 19 | | 35 | | 42 | | 44 |.|
     |____| |____| |____| |____|     |.|____| |____| |____| |____|.|
                                     |.............................|

   * After the final merging, the list should look like this −

      ____   ____   ____   ____   ____   ____   ____   ____ 
     | 10 | | 14 | | 19 | | 27 | | 33 | | 35 | | 42 | | 44 |
     |____| |____| |____| |____| |____| |____| |____| |____| 
   
   * Now we should learn some programming aspects of merge
     sorting.

       + Algorithm -
         ````````````
    * Merge sort keeps on dividing the list into equal halves until it can
      no more be divided.
    * By definition, if it is only one element in the list, it is sorted. 
    * Then, merge sort combines the smaller sorted lists keeping the new
      list sorted too.
    ________________________________________________________________________________________
   |
   |  Step 1 − if it is only one element in the list it is already sorted, return.
   |  Step 2 − divide the list recursively into two halves until it can no more be divided.
   |  Step 3 − merge the smaller lists into new list in sorted order.
   |_________________________________________________________________________________________

       + Pseudocode -
         `````````````
    * We shall now see the pseudocodes for merge sort functions.
    * As our algorithms point out two main functions − 
      divide & merge.
      ''''''   ''''' 
    * Merge sort works with recursion and we shall see our
      implementation in the same way.
   _________________________________________________________________
  |
  |  procedure mergesort( var a as array )
  |     if ( n == 1 ) return a
  |
  |     var l1 as array = a[0] ... a[n/2]
  |     var l2 as array = a[n/2+1] ... a[n]
  |
  |     l1 = mergesort( l1 )
  |     l2 = mergesort( l2 )
  |
  |     return merge( l1, l2 )
  |  end procedure
  |
  |  procedure merge( var a as array, var b as array )
  |
  |     var c as array
  |     while ( a and b have elements )
  |        if ( a[0] > b[0] )
  |           add b[0] to the end of c
  |           remove b[0] from b
  |        else
  |           add a[0] to the end of c
  |           remove a[0] from a
  |        end if
  |     end while
  | 
  |     while ( a has elements )
  |        add a[0] to the end of c
  |        remove a[0] from a
  |     end while
  | 
  |     while ( b has elements )
  |        add b[0] to the end of c
  |        remove b[0] from b
  |     end while
  | 
  |     return c
  | 	
  |  end procedure
  |___________________________________________________________________
      
     * About merge sort implementation in C programming language -
             ```````````````````````````````````````````````````
     * Implementation of 'merge sort' in C -
       `````````````````````````````````````
    ______________________________________________________________________
   |  #include <stdio.h>
   |
   |  #define max 10
   |
   |  int a[11] = { 10, 14, 19, 26, 27, 31, 33, 35, 42, 44, 0 };
   |  int b[10];
   |
   |  void merging(int low, int mid, int high) {
   |     int l1, l2, i;
   |     
   |     for(l1 = low, l2 = mid + 1, i = low; l1 <= mid && l2 <= high; i++) {
   |        if(a[l1] <= a[l2])
   |           b[i] = a[l1++];
   |        else
   |           b[i] = a[l2++];
   |     }
   |
   |     while(l1 <= mid)    
   |        b[i++] = a[l1++];
   |
   |     while(l2 <= high)   
   |        b[i++] = a[l2++];
   |
   |     for(i = low; i <= high; i++)
   |        a[i] = b[i];
   |  }
   | 
   |  void sort(int low, int high) {
   |     int mid;
   |
   |     if(low < high) {
   |        mid = (low + high) / 2;
   |        sort(low, mid);
   |        sort(mid+1, high);
   |        merging(low, mid, high);
   |     } else { 
   |        return;
   |     }   
   |  }
   |
   |  int main() { 
   |     int i;
   |
   |     printf("List before sorting\n");
   |
   |     for(i = 0; i <= max; i++)
   |        printf("%d ", a[i]);
   | 
   |     sort(0, max);
   |
   |     printf("\nList after sorting\n");
   | 
   |     for(i = 0; i <= max; i++)
   |        printf("%d ", a[i]);
   |  }
   |__________________________________________________________________  
     
      * compile and run the above program, it will produce the
        result -
                   Output -
    ________________________________________
   |  List before sorting
   |  10 14 19 26 27 31 33 35 42 44 0
   |  List after sorting
   |  0 10 14 19 26 27 31 33 35 42 44
   |________________________________________
__________________________________________________
                                                  |
         DSA - Merge Sort                         |                  
__________________________________________________|
            |
            |
1) What's the Heading ?
-----------------------
* DSA - Merge Sort
                                                                                        
2) Definition of Merge Sort ?
-----------------------------
*
 
3) What is Merge Sort About ?
-----------------------------
* 
*

4) What does Merge Sort Do ?
----------------------------
*
*

5) Advantages/Benefits of Merge Sort :
--------------------------------------
*
*
*

6) Disadvantages/Drawback of Merge Sort :
-----------------------------------------
*
*
*  

7) Examples of Merge Sort :
---------------------------
*
*
_______________________________________________________________________________

 6. <<<<<<<<< DSA - Shell Sort >>>>>>>>>
 
   * Shell sort is a highly efficient sorting algorithm and is based on
     insertion sort algorithm.
   * This algorithm avoids large shifts as in case of insertion sort, 
     if the smaller value is to the far right and has to be moved to
     the far left.
   
   * This algorithm uses insertion sort on a widely spread elements,   
     first to sort them and then sorts the less widely spaced elements.
   * This spacing is termed as "interval".
   * This 'interval' is calculated based on Knuth's formula as -
       
     "Knuth's Formula"
      ````````````````
    _________________________________________________
   |
   |  h = h * 3 + 1
   |  where −
   |     h is interval with initial value 1
   |_________________________________________________
     
   * This algorithm is quite efficient for medium-sized data sets as its
     average and worst-case complexity of this algorithm depends on the 
     gap sequence the best known is Ο(n), where n is the number 
     of items.                     '''''       ''' 
   * And the worst case space complexity is O(n). 
                        ''''''''''''''''''''====
      ** How Shell Sort Works ?
         ====================
    * Let us consider the following example to have an idea of how shell
      sort works.
    * We take the same array we have used in our previous examples.
    * For our example and ease of understanding, we take the interval
      of 4.
    * Make a virtual sub-list of all values located at the interval of
      4 positions.
    * Here these values are {35, 14}, {33, 19}, {42, 27} and {10, 44} -
   ___________________________________________________________     
  |   ____   ____   ____   ____   ____   ____   ____   ____   |
  |  | 35 | |/33/| | 42 | ||10|| | 14 | |/19/| | 27 | ||44||  | 
  |  |____| |////| |____| |||||| |____| |////| |____| ||||||  |
  |___________________________________________________________|
       |       |     |      |       |      |      |      |
       |       |     |      |       |      |      |      |
       V       |     |      |       V      |      |      |
     ____      |     |      |     ____     |      |      | 
    | 35 |     |     |      |    | 14 |    |      |      |
    |____|     |     |      |    |____|    |      |      |
               V     |      |              V      |      |
             ____    |      |            ____     |      |
            |/33/|   |      |           |/33/|    |      |
            |////|   |      |           |////|    |      |
                     |      |                     |      |
                     V      |                     V      |
                   ____     |                   ____     |
                  | 42 |    |                  | 27 |    |
                  |____|    |                  |____|    |
                            V                            V
                          ____                         ____
                         ||10||                       ||44|| 
                         ||||||                       ||||||
______________________________________________________________________________

  
   ___________________________________________________________     
  |   ____   ____   ____   ____   ____   ____   ____   ____   |
  |  | 35 | |/33/| | 42 | ||10|| | 14 | |/19/| | 27 | ||44||  | 
  |  |____| |////| |____| |||||| |____| |////| |____| ||||||  |
  |___________________________________________________________|
       |       |     |      |       |      |      |      |
       |       |     |      |       |      |      |      |
       V       |     |      |       V      |      |      |
     ____      |     |      |     ____     |      |      | 
    | 35 |-----|-----|------|----| 14 |    |      |      |
    |____|-----|-----|------|----|____|    |      |      |
               V     |      |              V      |      |
             ____    |      |            ____     |      |
            |/33/|///|//////|///////////|/33/|    |      |
            |////|///|//////|///////////|////|    |      |
                     |      |                     |      |
                     V      |                     V      |
                   ____     |                   ____     |
                  | 42 |----|------------------| 27 |    |
                  |____|----|------------------|____|    |
                            V                            V
                          ____                         ____
                         ||10|||||||||||||||||||||||||||44|| 
                         |||||||||||||||||||||||||||||||||||
   
    * We compare values in each sub-list and swap them (if necessary)
      in the original array.
    *  After this step, the new array should look like this −
       
   ___________________________________________________________     
  |   ____   ____   ____   ____   ____   ____   ____   ____   |
  |  | 14 | |/19/| | 27 | ||10|| | 35 | |/33/| | 42 | ||44||  | 
  |  |____| |////| |____| |||||| |____| |////| |____| ||||||  |
  |___________________________________________________________|
    
    * Then, we take interval of 1 and this gap generates two sub-lists -
      {14, 27, 35, 42}, {19, 10, 33, 44}

   ___________________________________________________________     
  |   ____   ____   ____   ____   ____   ____   ____   ____   |
  |  | 14 | |/19/| | 27 | |/10/| | 35 | |/33/| | 42 | |/44/|  | 
  |  |____| |////| |____| |////| |____| |////| |____| |////|  |
  |___________________________________________________________|  
       |       |      |      |      |      |      |      | 
       |       |      |      |      |      |      |      |
       V       |      V      |      V      |      V      |
     ____      |    ____     |    ____     |    ____     |
    | 14 |     |   | 27 |    |   | 35 |    |   | 42 |    |
    |____|     |   |____|    |   |____|    |   |____|    |
               V             V             V             V
             ____           ____         ____          ____
            |/19/|         |/10/|       |/33/|        |/44/| 
            |////|         |////|       |////|        |////|

_____________________________________________________________________________


   ___________________________________________________________     
  |   ____   ____   ____   ____   ____   ____   ____   ____   |
  |  | 14 | |/19/| | 27 | |/10/| | 35 | |/33/| | 42 | |/44/|  | 
  |  |____| |////| |____| |////| |____| |////| |____| |////|  |
  |___________________________________________________________|  
       |       |      |      |      |      |      |      | 
       |       |      |      |      |      |      |      |
       V       |      V      |      V      |      V      |
     ____      |    ____     |    ____     |    ____     |
    | 14 |-----|---| 27 |----|---| 35 |----|---| 42 |    |
    |____|-----|---|____|----|---|____|----|---|____|    |
               V             V             V             V
             ____           ____         ____          ____
            |/19/|/////////|/10/|///////|/33/|////////|/44/| 
            |////|/////////|////|///////|////|////////|////|
  
    * We compare and swap the values, if required, in the original array.
    * After this step, the array should look like this −
 
   ___________________________________________________________     
  |   ____   ____   ____   ____   ____   ____   ____   ____   |
  |  | 14 | |/19/| | 27 | |/10/| | 35 | |/33/| | 42 | |/44/|  | 
  |  |____| |////| |____| |////| |____| |////| |____| |////|  |
  |___________________________________________________________| 
    
    * Finally, we sort the rest of the array using interval of value 1.
    * Shell sort uses insertion sort to sort the array.
    
    * Following is the step-by-step depiction −
       
   ___________________________________________________________     
  |   ____   ____   ____   ____   ____   ____   ____   ____   |
  |  |/14/| | 19 | | 27 | | 10 | | 35 | | 33 | | 42 | | 44 |  | 
  |  |////| |____| |____| |____| |____| |____| |____| |____|  |
  |___________________________________________________________|

   ___________________________________________________________     
  |   ____   ____   ____   ____   ____   ____   ____   ____   |
  |  |/14/| |/19/| | 27 | | 10 | | 35 | | 33 | | 42 | | 44 |  | 
  |  |////| |////| |____| |____| |____| |____| |____| |____|  |
  |___________________________________________________________|

   ___________________________________________________________     
  |   ____   ____   ____   ____   ____   ____   ____   ____   |
  |  |/14/| |/19/| |/27/| | 10 | | 35 | | 33 | | 42 | | 44 |  | 
  |  |////| |////| |////| |____| |____| |____| |____| |____|  |
  |___________________________________________________________|

   ___________________________________________________________     
  |   ____   ____   ____   ____   ____   ____   ____   ____   |
  |  |/14/| |/19/| |/27/| |-10-| | 35 | | 33 | | 42 | | 44 |  | 
  |  |////| |////| |////| |----| |____| |____| |____| |____|  |
  |___________________________________________________________|
   
   ___________________________________________________________     
  |   ____   ____   ____   ____   ____   ____   ____   ____   |
  |  |/14/| |/19/| |-10-| |/27/| | 35 | | 33 | | 42 | | 44 |  | 
  |  |////| |////| |----| |////| |____| |____| |____| |____|  |
  |___________________________________________________________|

   ___________________________________________________________     
  |   ____   ____   ____   ____   ____   ____   ____   ____   |
  |  |/14/| |-10-| |/19/| |/27/| | 35 | | 33 | | 42 | | 44 |  | 
  |  |////| |----| |////| |////| |____| |____| |____| |____|  |
  |___________________________________________________________|

   ___________________________________________________________     
  |   ____   ____   ____   ____   ____   ____   ____   ____   |
  |  |/10/| |/14/| |/19/| |/27/| |/35/| | 33 | | 42 | | 44 |  | 
  |  |////| |////| |////| |////| |////| |____| |____| |____|  |
  |___________________________________________________________|

   ___________________________________________________________     
  |   ____   ____   ____   ____   ____   ____   ____   ____   |
  |  |/10/| |/14/| |/19/| |/27/| |/35/| |-33-| | 42 | | 44 |  | 
  |  |////| |////| |////| |////| |////| |----| |____| |____|  |
  |___________________________________________________________|

   ___________________________________________________________     
  |   ____   ____   ____   ____   ____   ____   ____   ____   |
  |  |/10/| |/14/| |/19/| |/27/| |/33/| |/35/| | 42 | | 44 |  | 
  |  |////| |////| |////| |////| |////| |////| |____| |____|  |
  |___________________________________________________________|

   ___________________________________________________________     
  |   ____   ____   ____   ____   ____   ____   ____   ____   |
  |  |/10/| |/14/| |/19/| |/27/| |/33/| |/35/| |/42/| |/44/|  | 
  |  |////| |////| |////| |////| |////| |////| |////| |////|  |
  |___________________________________________________________|


   * We see that it required only four swaps to sort the rest of the array.
          
         + Algorithm -
           `````````
    * Following is the algorithm for shell sort -
    ______________________________________________________________________
   |  Step 1 − Initialize the value of h
   |  Step 2 − Divide the list into smaller sub-list of equal interval h
   |  Step 3 − Sort these sub-lists using insertion sort
   |  Step 3 − Repeat until complete list is sorted 
   \_____________________________________________________________________
        
     * Pseudocode -
       `````````````
      + Following is the pseudocode for shell sort -
    ______________________________________________________________________
   |
   |  procedure shellSort()
   |     A : array of items   
   |	  
   |     /* calculate interval*/
   |     while interval < A.length /3 do:
   |        interval = interval * 3 + 1	    
   |     end while
   | 
   |     while interval > 0 do:
   |
   |        for outer = interval; outer < A.length; outer ++ do:
   |
   |        /* select value to be inserted */
   |        valueToInsert = A[outer]
   |        inner = outer;
   | 
   |           /*shift element towards right*/
   |           while inner > interval -1 && A[inner - interval] >= valueToInsert do:
   |              A[inner] = A[inner - interval]
   |              inner = inner - interval
   |           end while
   | 
   |        /* insert the number at hole position */
   |        A[inner] = valueToInsert
   |
   |        end for
   |
   |     /* calculate interval*/
   |     interval = (interval -1) /3;	  
   |
   |     end while
   |
   |  end procedure
   |__________________________________________________________________
     
     * About shell sort implementation in C programming language -
             `````````````````````````````````````````````````````` 
     * Shell Sort Program in C -
       ``````````````````````````
   + Shell sort is a highly efficient sorting algorithm and is based on
     insertion sort algorithm.
   + This algorithm avoids large shifts as in case of insertion sort,
     if the smaller value is to the far right and has to be moved to
     the far left. 
          
        + Implementation in C -
          ``````````````````````
    _____________________________________________________________________
   |  #include <stdio.h>
   |  #include <stdbool.h>
   |
   |  #define MAX 7
   | 
   |  int intArray[MAX] = {4,6,3,2,1,9,7};
   |
   |  void printline(int count) {
   |     int i;
   |	
   |     for(i = 0;i < count-1;i++) {
   |        printf("=");
   |     }
   |	
   |     printf("=\n");
   |  }
   |
   |  void display() {
   |     int i;
   |     printf("[");
   |	
   |     // navigate through all items 
   |     for(i = 0;i < MAX;i++) {
   |        printf("%d ",intArray[i]);
   |     }
   |	
   |     printf("]\n");
   |  }
   |
   |  void shellSort() {
   |     int inner, outer;
   |     int valueToInsert;
   |     int interval = 1;   
   |     int elements = MAX;
   |     int i = 0;
   |
   |     while(interval <= elements/3) {
   |        interval = interval*3 +1;
   |     }
   |
   |     while(interval > 0) {
   |        printf("iteration %d#:",i); 
   |        display();
   |   
   |        for(outer = interval; outer < elements; outer++) {
   |           valueToInsert = intArray[outer];
   |           inner = outer;
   |		 	
   |           while(inner > interval -1 && intArray[inner - interval] 
   |              >= valueToInsert) {
   |              intArray[inner] = intArray[inner - interval];
   |              inner -=interval;
   |              printf(" item moved :%d\n",intArray[inner]);
   |           }
   |      
   |           intArray[inner] = valueToInsert;
   |           printf(" item inserted :%d, at position :%d\n",valueToInsert,inner);
   |        }
   |		
   |        interval = (interval -1) /3;
   |        i++;
   |     }          
   |  }
   |
   |  int main() {
   |     printf("Input Array: ");
   |     display();
   |     printline(50);
   |     shellSort();
   |     printf("Output Array: ");
   |     display();
   |     printline(50);
   |     return 1;
   |  }
   |________________________________________________________________________

     * compile and run the above program, it will produce the
       result -
                 Output -
   _________________________________________________________________
  |
  |  Input Array: [4 6 3 2 1 9 7 ]
  |  ==================================================
  |  iteration 0#:[4 6 3 2 1 9 7 ]
  |   item moved :4
  |   item inserted :1, at position :0
  |   item inserted :9, at position :5
  |   item inserted :7, at position :6
  |  iteration 1#:[1 6 3 2 4 9 7 ]
  |   item inserted :6, at position :1
  |   item moved :6
  |   item inserted :3, at position :1
  |   item moved :6
  |   item moved :3
  |   item inserted :2, at position :1
  |   item moved :6
  |   item inserted :4, at position :3
  |   item inserted :9, at position :5
  |   item moved :9
  |   item inserted :7, at position :5
  |  Output Array: [1 2 3 4 6 7 9 ]
  |  ==================================================
  |_________________________________________________________________
__________________________________________________
                                                  |
       DSA - Shell Sort                           |                  
__________________________________________________|
            |
            |
1) What's the Heading ?
-----------------------
* DSA - Shell Sort
                                                                                        
2) Definition of Shell Sort ?
-----------------------------
*
 
3) What is Shell Sort About ?
-----------------------------
*
* 

4) What does Shell Sort Do ?
----------------------------
* 
*

5) Advantages/Benefits of Shell Sort :
--------------------------------------
*
*
*

6) Disadvantages/Drawback of Shell Sort :
-----------------------------------------
*
*
*  

7) Examples of Shell Sort :
---------------------------
*
*
_______________________________________________________________________________

 7. <<<<<<<<< DSA - Quick Sort >>>>>>>>>
    
   * Quick sort is a highly efficient sorting algorithm and is based on
     partitioning of array of data into smaller arrays.
   * A large array is partitioned into two arrays one of which holds 
     values smaller than the specified value, say pivot, based on which
     the partition is made and another array holds values greater than 
     the pivot value.
   
   * Quicksort partitions an array and then calls itself recursively twice
     to sort the two resulting subarrays.
   * This algorithm is quite efficient for large-sized data sets as its
     average and worst-case complexity are O(n2), respectively.
                 ```````````````````````````````
       ** Partition in Quick Sort -
          =======================
   * Following animated representation explains how to find the pivot
     value in an array.
    
       
                     Unsorted Array -
                     -----------------
                        
      ____   ____   ____   ____   ____   ____   ____   ____   ____   ____
     | 35 | | 33 | | 42 | | 10 | | 14 | | 19 | | 27 | | 44 | | 26 | | 31 |
     |____| |____| |____| |____| |____| |____| |____| |____| |____| |____|
       
       lo                                                      hi    Pivot
      ____   ____   ____   ____   ____   ____   ____   ____   ____   ____
     | 35 | | 33 | | 42 | | 10 | | 14 | | 19 | | 27 | | 44 | | 26 | |^31^|
     |____| |____| |____| |____| |____| |____| |____| |____| |____| |^^^^|        
       
       |                                                       |
       |                                                       |
       V                                                       V 
       lo                                                      hi    Pivot
      ____   ____   ____   ____   ____   ____   ____   ____   ____   ____
     |-35-| | 33 | | 42 | | 10 | | 14 | | 19 | | 27 | | 44 | |-26-| |^31^|
     |----| |____| |____| |____| |____| |____| |____| |____| |----| |^^^^|               <                          >
      pivot                                                   pivot
                              Swap
        _______________________________________________________
       |                                                       |
       |                                                       |
       V                                                       V 
       lo                                                      hi    Pivot
      ____   ____   ____   ____   ____   ____   ____   ____   ____   ____
     |-35-| | 33 | | 42 | | 10 | | 14 | | 19 | | 27 | | 44 | |-26-| |^31^|
     |----| |____| |____| |____| |____| |____| |____| |____| |----| |^^^^|               <                                                        >
      pivot                                                   pivot

         ______________________________________________________
        |                                                      | 
        V                                                      V
       lo                                                      hi    Pivot
      ____   ____   ____   ____   ____   ____   ____   ____   ____   ____
     |/26/| | 33 | | 42 | | 10 | | 14 | | 19 | | 27 | | 44 | |/35/| |^31^|
     |////| |____| |____| |____| |____| |____| |____| |____| |////| |^^^^|
       <                                                        >
      pivot                                                   pivot
                          
                                Swap
               _________________________________________
              |                                         |  
              |                                         |
              V                                         V
              lo                                        hi           Pivot
      ____   ____   ____   ____   ____   ____   ____   ____   ____   ____
     | 26 | |-33-| | 42 | | 10 | | 14 | | 19 | |/27/| | 44 | | 35 | |^31^|
     |____| |----| |____| |____| |____| |____| |////| |____| |____| |^^^^|
      
                
                                             Swap
               _________________________________________
              |                                         |  
              |                                         |
              V                                         V
              lo                                        hi           Pivot
      ____   ____   ____   ____   ____   ____   ____   ____   ____   ____
     | 26 | |-33-| | 42 | | 10 | | 14 | | 19 | |/27/| | 44 | | 35 | |^31^|
     |____| |----| |____| |____| |____| |____| |////| |____| |____| |^^^^|
              
                                         Swap
               __________________________________
              |                                  |  
              V                                  V
              lo                                 hi                  Pivot
      ____   ____   ____   ____   ____   ____   ____   ____   ____   ____
     | 26 | |/27/| | 42 | | 10 | | 14 | | 19 | |/33/| | 44 | | 35 | |^31^|
     |____| |////| |____| |____| |____| |____| |////| |____| |____| |^^^^|
              <                                   >
             pivot                              pivot
                                       
                                    Swap
                      ____________________
                     |                    |
                     |                    |
                     V                    V                          Pivot
      ____   ____   ____   ____   ____   ____   ____   ____   ____   ____
     | 26 | | 33 | |-42-| | 10 | | 14 | |-19-| | 27 | | 44 | | 35 | |^31^|
     |____| |____| |----| |____| |____| |----| |____| |____| |____| |^^^^|
                     <                     > 
                    pivot                pivot
 
                       ___________________           
                      |                   | 
                      V                   V
      ____   ____   ____   ____   ____   ____   ____   ____   ____   ____
     | 26 | | 33 | |/19/| | 10 | | 14 | |/42/| | 27 | | 44 | | 35 | |^31^|
     |____| |____| |////| |____| |____| |////| |____| |____| |____| |^^^^|
                     <                     >
                    pivot                pivot  
                                                        Swap
                                           ___________________________           
                                          |                           | 
                                          V                           V
      ____   ____   ____   ____   ____   ____   ____   ____   ____   ____
     | 26 | | 33 | |/19/| | 10 | | 14 | |/42/| | 27 | | 44 | | 35 | |^31^|
     |____| |____| |////| |____| |____| |////| |____| |____| |____| |^^^^|
                     <                     >
                    pivot                pivot 
                                                             
                                           ___________________________           
                                          |                           | 
                                          V                           V
      ____   ____   ____   ____   ____   ____   ____   ____   ____   ____
     | 26 | | 33 | | 19 | | 10 | | 14 | |^31^| | 27 | | 44 | | 35 | |/42/|
     |____| |____| |____| |____| |____| |^^^^| |____| |____| |____| |////|
                                                             
                    
      ____   ____   ____   ____   ____   ____   ____   ____   ____   ____
     | 26 | | 33 | | 19 | | 10 | | 14 | |^31^| | 27 | | 44 | | 35 | | 42 |
     |____| |____| |____| |____| |____| |^^^^| |____| |____| |____| |____| 
       ^                           ^              ^                    ^ 
       |                           |              |                    |                 |___________________________|              |____________________|
              Partition #1                            Partition #2  
  
    * The pivot value divides the list into two parts.  
    * And recursively, we find the pivot for each sub-lists until all   
      lists contains only one element.        
                             
         ** Quick Sort Pivot Algorithm :
            ==========================
   * Based on our understanding of partitioning in quick sort, we will
     now try to write an 'algorithm' for it, which is as follows -
                          `````````
    ___________________________________________________________________________________
   |
   |  Step 1 − Choose the highest index value has pivot
   |  Step 2 − Take two variables to point left and right of the list excluding pivot
   |  Step 3 − left points to the low index
   |  Step 4 − right points to the high
   |  Step 5 − while value at left is less than pivot move right
   |  Step 6 − while value at right is greater than pivot move left
   |  Step 7 − if both step 5 and step 6 does not match swap left and right
   |  Step 8 − if left ≥ right, the point where they met is new 
   |______________________________________________________________________________
            
       ** Quick Sort Pivot Pseudocode :
          ===========================
   + The pseudocode for the above algorithm can be derived as −
    _________________________________________________________________
   |
   |  function partitionFunc(left, right, pivot)
   |     leftPointer = left
   |     rightPointer = right - 1
   |
   |     while True do
   |        while A[++leftPointer] < pivot do
   |           //do-nothing            
   |        end while
   |    		
   |        while rightPointer > 0 && A[--rightPointer] > pivot do
   |           //do-nothing         
   |        end while
   |  		
   |        if leftPointer >= rightPointer
   |           break
   |        else                
   |           swap leftPointer,rightPointer
   |        end if
   |		
   |     end while 
   |	
   |     swap leftPointer,right
   |     return leftPointer
   |	
   |  end function
   |__________________________________________________________________  
        
       ** Quick Sort Algorithm :
          ====================
   * Using pivot algorithm recursively, we end up with smaller possible
     partitions.
   * Each partition is then processed for quick sort.
   * We define recursive algorithm for quicksort as follows −
     _________________________________________________________
    |
    |  Step 1 − Make the right-most index value pivot
    |  Step 2 − partition the array using pivot value
    |  Step 3 − quicksort left partition recursively
    |  Step 4 − quicksort right partition recursively 
    |______________________________________________________
       
       ** Quick Sort Pseudocode :
          =====================
   * To get more into it, let see the pseudocode for quick sort algorithm −
    __________________________________________________________
   |  procedure quickSort(left, right)
   |
   |    if right-left <= 0
   |       return
   |    else     
   |       pivot = A[right]
   |       partition = partitionFunc(left, right, pivot)
   |       quickSort(left,partition-1)
   |       quickSort(partition+1,right)    
   |    end if		
   |
   | end procedure
   |_______________________________________________________
       
       * About quick sort implementation in C programming language :
                          ````````````````````````````````````````
       * Quick Sort Program in C -
         ``````````````````````````
    + Quick sort is a highly efficient sorting algorithm and is based on
      partitioning of array of data into smaller arrays.
    + A large array is partitioned into two arrays one of which
      holds values smaller than the specified value, say pivot, based
      on which the partition is made and another array holds values
      greater than the pivot value.
     
       Implementation in C -
       ``````````````````````
   _______________________________________________________________________
  | 
  |  #include <stdio.h>
  |  #include <stdbool.h>
  | 
  |  #define MAX 7
  |
  |  int intArray[MAX] = {4,6,3,2,1,9,7};
  |
  |  void printline(int count) {
  |     int i;
  |     	
  |     for(i = 0;i < count-1;i++) {
  |        printf("=");
  |     }
  |	
  |     printf("=\n");
  |  }
  |
  |  void display() {
  |     int i;
  |     printf("[");
  |	
  |     // navigate through all items 
  |     for(i = 0;i < MAX;i++) {
  |        printf("%d ",intArray[i]);
  |     }
  |	
  |     printf("]\n");
  |  }
  |
  |  void swap(int num1, int num2) {
  |     int temp = intArray[num1];
  |     intArray[num1] = intArray[num2];
  |     intArray[num2] = temp;
  |  }
  |
  |  int partition(int left, int right, int pivot) {
  |     int leftPointer = left -1;
  |     int rightPointer = right;
  |
  |     while(true) {
  |        while(intArray[++leftPointer] < pivot) {
  |           //do nothing
  |        }
  |		
  |        while(rightPointer > 0 && intArray[--rightPointer] > pivot) {
  |           //do nothing
  |        }
  |
  |        if(leftPointer >= rightPointer) {
  |           break;
  |        } else {
  |           printf(" item swapped :%d,%d\n", intArray[leftPointer],intArray[rightPointer]);
  |           swap(leftPointer,rightPointer);
  |        }
  |     }
  |	
  |     printf(" pivot swapped :%d,%d\n", intArray[leftPointer],intArray[right]);
  |     swap(leftPointer,right);
  |     printf("Updated Array: "); 
  |     display();
  |     return leftPointer;
  |  }
  |
  |  void quickSort(int left, int right) {
  |     if(right-left <= 0) {
  |        return;   
  |     } else {
  |        int pivot = intArray[right];
  |        int partitionPoint = partition(left, right, pivot);
  |        quickSort(left,partitionPoint-1);
  |        quickSort(partitionPoint+1,right);
  |     }        
  |  }
  |
  |  int main() {
  |     printf("Input Array: ");
  |     display();
  |     printline(50);
  |     quickSort(0,MAX-1);
  |     printf("Output Array: ");
  |     display();
  |     printline(50);
  |  }
  |__________________________________________________________________________
    
     *  compile and run the above program, it will produce the
        result -
                   Output -
     ____________________________________________________________
    |
    |  Input Array: [4 6 3 2 1 9 7 ]
    |  ==================================================
    |   pivot swapped :9,7
    |  Updated Array: [4 6 3 2 1 7 9 ]
    |   pivot swapped :4,1
    |  Updated Array: [1 6 3 2 4 7 9 ]
    |   item swapped :6,2
    |   pivot swapped :6,4
    |  Updated Array: [1 2 3 4 6 7 9 ]
    |   pivot swapped :3,3
    |  Updated Array: [1 2 3 4 6 7 9 ]
    |  Output Array: [1 2 3 4 6 7 9 ]
    |  ==================================================
    |____________________________________________________________
     
__________________________________________________
                                                  |
        DSA - Quick Sort                          |                  
__________________________________________________|
            |
            |
1) What's the Heading ?
-----------------------
* DSA - Quick Sort
                                                                                        
2) Definition of Quick Sort ?
-----------------------------
*
 
3) What is Quick Sort About ?
-----------------------------
*
*

4) What does Quick Sort Do ?
----------------------------
*
*

5) Advantages/Benefits of Quick Sort :
--------------------------------------
*
*
*

6) Disadvantages/Drawback of Quick Sort :
-----------------------------------------
*
*
*  

7) Examples of Quick Sort :
---------------------------
*
*
_______________________________________________________________________________